Guión de la práctica

NOTA: esta práctica es para ejecutarla usando un usuario normal, no hay que usar la cuenta de root.

PARTE 1: ARRANQUE, INICIALIZACIÓN Y TOMA DE CONTACTO

*Arrancar la simulación con vnumlparser.pl -t red_curso.xml. Se recomienda cambiar de escritorio virtual para que estén sólo las ventanas de la simulación y sea más cómodo acceder a ellas.
*Paulatinamente irán apareciendo las 6 ventanas correspondientes a las 6 máquinas virtuales que intervienen en la simulación; en cada una de ellas será visible la pantalla de login con el nombre de la máquina. En todas ellas el usuario para entrar es root y la password es xxxx.
*Estas son las máquinas que intervienen en la simulación:
**En casa del usuario
--casa: Esta máquina simula el ordenador en casa del usuario, conectada directamente a Internet (por ejemplo mediante un router en modo monopuesto, o se trata de un portátil conectado por un módem 3G). La característica principal de esta máquina es que tiene una IP visible en Internet, la 88.1.2.3, asociada a la interfaz eth1. Además la máquina tiene una segunda interfaz de red, eth2, que permite compartir la conexión a Internet con otras máquinas del usuario, en nuestra simulación con casa2. La IP de esta segunda interfaz es 192.168.1.1
--casa2: Otra máquina del usuario que se conecta a Internet a través de la conexión compartida por "casa". Si lo preferimos, en lugar de pensar en "casa" como un ordenador, por ejemplo un portátil como módem 3G, que comparte su conexión, podemos imaginar que es un router ADSL en modo multipuesto y casa2 está conectado a uno de sus puertos de red. Esta máquina tiene una única interfaz de red con IP 192.168.1.2 (por lo tanto una IP interna, no válida en Internet) y tiene como ruta por defecto la 192.168.1.1, la IP en la red local de "casa".
**En la empresa del usuario (dónde hay dos redes, una con los servidores y otra con los puestos de trabajo)
--router_o: Es el router de la oficina, que conecta las dos redes de la oficina entre sí y con internet. La interfaz eth1 es la que da la conexión directa a Internet, la IP de esta interfaz, 88.4.5.6, es una IP pública. La interfaz eth2, con IP 10.0.1.1, da acceso a la red de los puestos, en la que está "ordenador_o", el ordenador del usuario. La interfaz eth3, con IP 10.0.2.1 da acceso a la red de los servidores, en la que etá "servidor_o".
--orden_o: Es el ordenador que tiene el usuario en su empresa y básicamente el usuario quiere llegar con la VPN desde su casa a esta máquina. Tiene una única interfaz de red, con IP 10.0.1.92 (por lo tanto una dirección interna no válida en Internet) y la ruta por defecto es la 10.0.1.1, es decir, la IP de router_o en esta red.
--servidor_o: Es un servidor que está en la red local de servidores de la empresa. Tiene como IP la 10.0.2.16 (por lo tanto una dirección interna no enrutable desde Internet) y la ruta por defecto es la 10.0.2.1, la IP de router_o en esta red. El papel en esta simulación será para experimentar con que este ordenador sea o no accesible desde la VPN.
**En Internet
--proved: Esta máquina simula el router del proveedor de Internet tanto de la conexión de casa del usuario como la de la empresa. Por supuesto no tiene por que ser el mismo, la cuestión es simplemente simular el tramo de Internet a través del cual se pueden comunicar. Las IPs son lo de menos, no influyen ni tienen interés en la simulación. El único interés de acceder a esta mánica es para poner un sniffer (por ejemplo tcpdump) para ver como afectan las distintas configuraciones y diagnosticar los errores. Por ejemplo con tcpdump -i eth1 se ven los paquetes procedentes y con destino a la red de la casa del usuario.
*Inicialmente no está activa la NAT en los routers, por lo que los únicos ordenadores que tienen conexión a Internet son router_o y casa, al ser los únicos con una dirección válida. Podemos comprobarlo haciendo ping de casa a router_o (ping 88.4.5.6) y comprobando que funciona, mientras que ping desde casa2 a router_o o desde orden_o a casa no funcionan. Podemos ver el motivo por el que no funcionan ejecutando en proved el comando "tcpdump -i eth1" y hacer un ping desde rout_o a casa (ping 88.1.2.3). Veremos que el ping llega hasta casa y responde, pero como la IP de origen del ping es la 10.0.1.92 (la IP de orden_o) los paquetes de respuesta van a esta IP y cuando llegan a proved no sabe cómo llegar hasta esta IP, al ser una IP interna. Hay que decir que en una configuración más real posiblemente el ping no llegue siquiera hasta "casa" debido a que lo filtre algún router al comprobar que la dirección de origen es no enrutable.
*Para activar el NAT ejecutamos en nuestro PC, desde la ventana en la que arrancamos la simulación, vnumlparser.pl -x snat@red_curso.xml; esta orden ejecuta el contenido que está dentro del tag "exec" con atribute sec="snat". Hecho esto ya podemos comprobar que el ping desde orden_o a casa ya llega; con tcpdump en la máquina proved podemos comprobar que el ping ya no viene de la 10.0.1.92 sino de la 88.4.5.6, porque las reglas NAT en router_o aplican este cambio y luego vuelven a cambiar de 88.4.5.6 a 10.0.1.92 con los paquetes de respuesta.
*Por supuesto sigue sin funcionar un ping con destino casa2, orden_o o serv_o, pues ninguna de estas tres máquinas tiene una IP pública y al llegar al router del proveedor no sabe cómo seguir. Para llegar a estas máquinas hay que establecer una VPN: vamos a ver cómo hacerlo con IPsec y con OpenVPN.

PARTE 2: IPSEC

*Ejecutar en primer lugar vnumlparser.pl -x subir@red_curso.xml; esta orden pone en el directorio /root de las máquinas virtuales casa, casa2, orden_o y router_o los ficheros contenidos en conf/, necesarios para el resto de la práctica.
*Vamos a crear un túnel cifrado entre router_o y casa, que va crear una VPN entre la red 192.168.1.0 (es decir, casa y casa2) y la máquina orden_o. Para ello ejecutamos vnumlparser.pl -x ipsec@red_curso.xml; esta orden ejecuta en router_o "setkey -f politicas_router_oficina" y en casa "setkey -f politicas_casa". Los ficheros politicas_router_oficina y politicas_casa. Observar en los ficheros de políticas como en primer lugar se definen las SA (security associations) que son los datos sobre los mecanismos a utilizar para securizar la comunicación entre las máquinas o redes especificadas; en nuestro ejemplo se establece que se utilizará entre las IPs 88.1.2.3 y 88.4.5.6 el algoritmo de cifrado 3DES y se indica el par de claves a utilizar (una para cada sentido). La otra información que aparece es la política de seguridad (SP), que son reglas para indicar qué hacer con el tráfico entre dos IPs o redes; en nuestro caso establecemos que las comunicaciones entre la IP 10.0.1.92 y la red 192.168.1.0 debe ir por el túnel creado entre la 88.1.2.3 y 88.4.5.6.
*Al tratar de hacer un ping desde orden_o a casa2 vemos que sigue sin funcionar. El motivo es que se aplica el NAT antes que aplicarse la política IPsec que establece que las comunicaciones de 10.0.1.92 a la red 192.168.1.0 deben ir por el túnel; de este modo al módulo IPsec la IP ya le llega cambiada a 88.4.5.6 (la IP pública de router_o) y no hay una política de seguridad que diga que hay que usar el túnel para las comunicaciones entre la IP 88.4.5.6 y la red 192.168.1.0. Aparentemente una solución es crear tal política de seguridad, pero tendría efectos colaterales, en concreto que sería autorizar a todas las máquinas de la empresa, por ejemplo servidor_o, dado que sobre todas ellas y no sólo sobre 10.0.1.92 se aplica el NAT. La solución real, dado que el problema es con el NAT, es hacer que no se aplique el NAT cuando la IP de origen es la 10.0.1.92 y el destino es la red 192.168.1.0. A tal fin ejecutamos en router_o el script./salta_snat_oficina.sh  que inserta una regla al comienzo de la cadena POSTROUTING de la tabla nat para que a este tipo de tráfico no se le aplique la regla que se ha añadido para hacer NAT. En el otro extremo, en casa, ocurre el mismo problema y la solución está en ejecutar ./salta_snat_casa.sh. Tras estos pasos ya podemos ejecutar desde casa2 un ping a ordena_o y constatar que funciona. Con tcpdump podemos comprobar en proved que el tráfico va encapsulado en paquetes ESP con las IPs 88.1.2.3 y 88.4.5.6.
*Si tratamos de hacer un ping desde casa a orden_o no funciona, mientras que sí lo hace de orden_o a casa. El motivo es que en un PC multihome (con varias interfaces de red) los paquetes locales por defecto se generan con IP origen la IP de la interfaz de salida. En este caso la interfaz de salida es la de Internet, por lo que los paquetes llevan como IP origen la 88.1.2.3 en lugar de la 192.168.1.1 y por lo tanto no se aplica la política de IPsec para usar el túnel. Para este caso hay dos soluciones. La más general es añadir una regla con iptables para hacer nat en el tráfico originado en casa cuando el destino sea la 10.0.1.92, pero a la 192.168.1.1, así los paquetes irán por el túnel IPsec. La solución más específica, porque depende de cada programa, es utilizar el mecanismo del programa que estemos usando para seleccionar la IP o interfaz de origen. Por ejemplo con ping esto se hace con la opción -I; podemos comprobar que ping -I eth2 10.0.1.92 sí que funciona porque ahora la IP origen es la 192.168.1.1.
*Un detalle a observar con el túnel IPsec que va a ser diferente a lo que hace openvpn y el resto de implementaciones: podemos comprobar ejecutando "ifconfig -a" que ni en router_o ni en casa se ha creado una interfaz virtual de red, ni ha habido que añadir rutas con route. El kernel se encarga de todo y la presencia del túnel no se traduce en que haya una interfaz nueva o un proceso en ejecución; hay implementaciones de IPsec no obstante en que sí se crea una interfaz virtual, aunque nos parece más coherente el modelo seguido en la implementación que usa Linux (que es común con varios BSD Unix incluyendo MacOS X). 

PARTE 3: OPENVPN

*en primer lugar, vamos a desactivar el túnel creado con ipsec, porque vamos a crear un túnel nuevo usando ahora openvpn. Para ello ejecutamos vnumlparser.pl -x ipsecd@red_curso.xml. Podemos comprobar que el túnel ya no funciona, ya no se puede hacer ping de orden_o a casa2; así mismo "setkey -D" y "setkey -DP" que antes mostraban en casa y router_o respectivamente la SAD y SPD (base de datos de asociaciones de seguridad y base de datos de políticas de seguridad) ya no muestran nada.
*en router_o ejecutamos "cd openvpn ; ./openvpn_router_o_casa.sh" y en casa ejecutamos "cd openvpn ; ./openvpn_casa_router_o.sh". Con estos pasos podemos comprobar que desde casa2 llegamos a orden_o y viceversa.
*si comparamos con el túnel ipsec, vemos que ahora sí aparece una interfaz virtual nueva de tipo punto a punto (tun1), con IPs privadas  192.168.255.1 y 192.168.255.2 y que ha habido que añadir entradas en las tablas de rutas. Otro detalle es que si no queremos que viaje por el túnel tráfico con origen o destino serv_o, habrá que añadir reglas con iptables para rechazar estos paquetes, mientras que con IPsec no había que hacer nada, dado que sólo va por el túnel el tráfico para el que existe una política de seguridad definida. Aparentemente bastaría con no poner la ruta a la red 10.0.2.0  en el extremo casa, pues sin esta regla los paquetes de vuelta no irían por el túnel, pero esto no evitaría que los paquetes de ida sí llegaran, como podemos comprobar con netcat. Por ejemplo, en el ordenador casa2, ejecutar netcat -l -u -p 10001 y en serv_o ejecutar netcat -u 192.168.1.2 10001; podemos comprobar que al escribir desde serv_o aparece el texto en casa2, mientras que al teclear en casa2 no aparece nada en serv_o al no haber ruta para los mensajes de vuelta. El par de reglas a añadir están comentadas en los ficheros openvpn_router_o_casa.sh y openvpn_casa_router_o.sh.
*destruir el túnel con killall openvpn en las dos máquinas y quitar las reglas de filtrado con iptables -F. A continuación vamos a intentar crear el túnel desde otras máquinas, estando una de ellas detrás del NAT y la otra no. Por ejemplo un túnel entre casa2 y router_o. Para ello en router_o ahora vamos a invocar openvpn_router_o_casa2.sh y en casa2 vamos a ejecutar openvpn_casa2_router_o.sh.
*destruir el túnel anterior con killall openvpn en las dos máquinas. Ahora vamos a establecer un túnel entre casa2 y orden_o. Como las dos máquinas están detrás de NAT, no será posible establecer una comunicación. La solución está en abrir puertos en router_o, de tal modo que ahora el puerto UDP 10000 de 88.4.5.6 está redirigido al puerto UDP 8080 de 10.0.1.92. Ejecutar para ello vnumlparser.pl -x dnat@red_curso.xml. A continuación creamos el túnel ejecutando en orden_o el script./openvpn_orden_o_casa2.sh y en casa2 invocando ./openvpn_casa2_orden_o.sh.
*en este último caso aparece una complicación, consecuencia de que el túnel no esté en el router: ¿cómo llegar desde casa2 a serv_o y viceversa? está claro que usando para casa2 la IP 192.168.1.2 no es posible, pues ni serv_o ni el router saben como llegar hasta esa IP. Caben dos soluciones: si sólo se quiere llegar de casa2 a serv_o pero no hace falta por ejemplo hacer un ssh de serv_o a casa2, basta con que orden_o haga NAT y las conexiones procedentes de 192.168.1.2 usen su IP. Si es necesario permitir conectarse a puertos de casa2, la solución está en usar una IP libre de la red 10.0.1.0 (en nuestro caso la 10.0.1.93) y que mediante proxyarp orden_o conteste con su dirección MAC cuando haya una petición ARP para esta IP. El script para activar el proxyarp es proxyarp.sh. Observesé que con esto serv_o llega hasta casa2, pero usando la IP 10.0.1.93, no la 192.168.1.2.
