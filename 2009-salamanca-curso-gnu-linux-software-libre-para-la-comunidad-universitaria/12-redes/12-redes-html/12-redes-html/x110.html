<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Capa de red: capa IP (Layer3)</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="GNU/Linux, software libre para la comunidad universitaria"
HREF="index.html"><LINK
REL="UP"
TITLE="Paquetes de red. Modelo en Capas"
HREF="c49.html"><LINK
REL="PREVIOUS"
TITLE="Paquetes de red. Modelo en Capas"
HREF="c49.html"><LINK
REL="NEXT"
TITLE="Capa de transporte (Layer4)"
HREF="x170.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GNU/Linux, software libre para la comunidad universitaria: Redes privadas virtuales en GNU/Linux</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c49.html"
ACCESSKEY="P"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Cap狎ulo 2. Paquetes de red. Modelo en Capas</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x170.html"
ACCESSKEY="N"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN110"
>2.2. Capa de red: capa IP (Layer3)</A
></H1
><P
>Sobre la capa de enlace de datos va la capa IP; en realidad pueden ir otro tipo de capas de protocolos distintos a IP, como IPX, el protocolo de Netware, pero nos centraremos s칩lo en los paquetes IP que son los que se usan en la casi totalidad de las redes locales de hoy en d칤a adem치s de por supuesto en Internet.</P
><P
>Un paquete IP se llama datagrama. La informaci칩n m치s importante que incluye un datagrama es la IP de origen y la IP destino.</P
><P
>Las direcciones IP a diferencia de las MAC est치n pensadas para ser enrutables, es decir, hay unos nodos enrutadores que examinan la direcci칩n destino y deciden por qu칠 camino siguen los paquetes. Gracias a que las direcciones IP se asignan por grupos a las distintas organizaciones y proveedores de Internet es factible establecer rutas. Esto con las direcciones MAC ser칤a imposible: como vienen a equivaler a n칰meros de serie del hardware son in칰tiles para enrutar: puedo tener dos equipos juntos con MACs que no tienen nada que ver porque son de fabricantes distintos o uno tiene a침os m치s que el otro: quiz치s el nodo con la siguiente MAC a la nuestra se vendi칩 en una ciudad de Jap칩n.</P
><P
>Hay rangos de direcciones IP que est치n reservados para uso privado dentro de una organizaci칩n. Por ejemplo todas las direcciones que empiezan por 192.168.<A
NAME="AEN116"
HREF="#FTN.AEN116"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>. En las empresas, o en los hogares cuando se tienen varios ordenadores en casa y se quiere compartir la ADSL, lo habitual es usar direcciones de este tipo (privadas) en lugar de direcciones IP p칰blicas. Las direcciones privadas no son enrutables fuera del 치mbito en que se usan, por lo que no son utilizables para conectarse fuera de la red local. Por ejemplo no podemos conectarnos v칤a mensajer칤a instant치nea a un usuario de Internet utilizando la IP 192.168.120.7, porque los paquetes de respuesta no nos llegar칤an, dado que esa IP no es p칰blica y no es p칰blica porque puede haber mucha gente que la est치 usando en su red local. La soluci칩n est치 en el uso del NAT (Network Address Translator). El enrutador de salida a Internet de nuestra red modifica el paquete IP para que use como direcci칩n IP origen la IP p칰blica que tiene asignada la empresa y guarda en una tabla informaci칩n para hacer la modificaci칩n inversa en los paquetes de respuesta entrantes.</P
><P
>Siempre que hay enrutado y esto incluye casos especiales como tener una VPN en un nodo, hay que activar el forwarding. Para ello hay que ejecutar <KBD
CLASS="userinput"
>sysctl net.ipv4.ip_forward=1</KBD
>. El forwarding consiste simplemente en que si un paquete viene por una interfaz de red (por ejemplo eth0) y se ve por la tabla de rutas que est치 destinado a la red de otra interfaz (por ejemplo la eth1) se traspasa a esa otra interfaz. Tambi칠n es posible activar el forwarding para unas interfaces de red s칤 y para otras no, por ejemplo para eth0 ser칤a <KBD
CLASS="userinput"
>sysctl net.ipv4.conf.eth0.forwarding=1</KBD
>.</P
><P
>Hay una parte de la direcci칩n que indica el nodo dentro de la red pero otra indica la red. Los enrutadores tienen rutas para saber por d칩nde tienen que encaminar los paquetes seg칰n la parte de red destino, con una ruta por defecto para los paquetes que no encajan en ninguna de las otras rutas. Los enrutadores s칩lo suelen tener en cuenta la direcci칩n destino, no la direcci칩n origen, pero en GNU/Linux hay herramientas avanzadas que permiten considerar tambi칠n la direcci칩n origen.</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN122"
>2.2.1. M치scaras de red. Notaci칩n CIDR</A
></H2
><P
>Es importante conocer no s칩lo la IP de un equipo, sino su red. Para determinar la red a la que pertenece un equipo a partir de su IP, se usa la m치scara de red, que al aplicar a nivel de bits un AND sobre la IP nos da la red. Una notaci칩n m치s concisa que utilizar el par IP y m치scara de red es la notaci칩n CIDR: tras la direcci칩n IP, separado por / se indica el n칰mero de bits a uno de la m치scara de red. Por ejemplo, 192.168.120.19/24 indica que la m치scara de bits es de 255.255.255.0. Esta notaci칩n adem치s de m치s concisa tiene la ventaja que es m치s r치pido de ver cuantos nodos tiene una red, pues es 2^(32-x)-2; en nuestro caso ser칤a 2^(32-24) = 2^8-2= 254.</P
><P
>La m치scara de red m치s grande (es decir, la red con menos nodos) es 30, con lo que tendr칤a 2^2-2=2. El motivo de restar 2 unidades es que el primer valor (con todos los bits a cero) es la propia red y el 칰ltimo (con todos los bits a 1) es la direcci칩n de broadcast, es decir, la utilizada para enviar un paquete a todos los nodos de una red. As칤 pues, una red de este tipo es 칰til para definir una red para una conexi칩n punto a punto, por ejemplo para una conexi칩n que se usa 칰nicamente para enlazar dos redes.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN126"
>2.2.2. Enrutamiento din치mico</A
></H2
><P
>Hay protocolos de frontera interior como RIP, OSPF, IS-IS y protocolos de frontera exterior, como BGP<A
NAME="AEN129"
HREF="#FTN.AEN129"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
>. El programa recomendado es o bien Zebra o Quagga (este 칰ltimo es un fork surgido de Zebra). Hay otros programas, como Routed (parte de netkit), que s칩lo es adecuado si no vamos a utilizar m치s que RIP, Gated (que no es libre) o Bird, con desarrollo menos activo. Un art칤culo algo antiguo, pero que puede servir de introducci칩n a los protocolos de enrutamiento, se public칩 en Linux Magazine: <A
HREF="http://www.linux-magazine.com/issue/31/Zebra.pdf"
TARGET="_top"
>http://www.linux-magazine.com/issue/31/Zebra.pdf</A
></P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN132"
>2.2.3. Paquetes ICMP, IGMP</A
></H2
><P
>Los paquetes ICMP (Internet Control Message Protocol) son paquetes de control, que van sobre la capa IP pero siguen siendo parte de la capa de red. Por ejemplo son los paquetes que se reciben cuando se recibe un error de que no se ha podido establecer una conexi칩n a un puerto o que no hay ruta para llegar a una red. Son tambi칠n los paquetes que se env칤an y reciben al hacer un ping para comprobar si llegamos a una red. De los paquetes ICMP s칩lo nos interesa saber que llevan un campo con el tipo de mensaje, que ser치 el campo por el que filtraremos o dejaremos pasar este tipo de mensajes en nuestro cortafuegos. Con iptables -p icmp -h se ven los tipos de paquetes ICMP.</P
><P
>Los paquetes IGMP son paquetes de control para multicast (multidifusi칩n). El origen del modo multicast es que hay comunicaciones en las que los mismos paquetes son de inter칠s de varios nodos destino en lugar de uno solo; el ejemplo m치s socorrido es una emisi칩n de v칤deo. Si se transmite una pel칤cula usando unicast (el modo normal de comunicaci칩n IP) entonces se transmitir치 un paquete por cada destinatario, mientras que con multicast en los tramos comunes a todos los destinatarios ir치 un solo paquete. El multicast se basa en rangos de Ips reservados para este fin, pero no hablaremos m치s de 칠l porque se usa muy raramente. No hay que confudir multicast con broadcast: este 칰ltimo es enviar a todos los nodos de la red, el multicast es m치s restringido.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN136"
>2.2.4. Vinculaci칩n entre capa de red y enlace de datos</A
></H2
><P
>A nivel de red se utilizan direcciones Ips, pero las redes locales a nivel f칤sico utilizan Ethernet, por lo que en 칰ltimo t칠rmino para enviar un paquete a una m치quina de la red local no basta con utilizar su IP, adem치s en la parte de cabeceras Ethernet habr치 que poner su direcci칩n MAC. El protocolo que permite averiguar la direcci칩n MAC de una m치quina a partir de su IP es ARP. El funcionamiento de ARP se basa en utilizar una direcci칩n de broadcast Ethernet para preguntar a todos los nodos de la red local qui칠n tiene una determinada IP: la respuesta se cachea en cada host para evitar preguntarla cada vez. Con el comando arp de Unix se puede ver y manipular la tabla que convierte de IP a direcci칩n MAC en una m치quina.</P
><P
>Existe un protocolo llamada RARP (reverse ARP) que hace lo contrario que ARP: a partir de la MAC un servidor responde qu칠 Ip tenemos. Se usa para hacer los nodos de la red autoconfigurables, pero se considera preferible usar un protocolo m치s avanzado como BOOTP o DHCP.</P
><P
>GNU/Linux incluye soporte de ProxyARP. Un proxy ARP es una m치quina que responde peticiones ARP en nombre de otras m치quinas que estando en la misma red IP que el nodo que hace la petici칩n, no est치n en la misma red f칤sica (ni est치n unidas por un hub, switch o bridge). El uso m치s t칤pico es para poner equipos detr치s de un cortafuegos, pero usando Ips de la misma red que el resto de equipos. El host que act칰a de proxyARP ante una petici칩n ARP a una IP de la que hace de proxy responde con su propia direcci칩n MAC; luego cuando le lleguen paquetes los redirigir치 a la m치quina. Otro uso importante es para que un nodo que accede a trav칠s de una VPN a la red local pueda tener una IP local, sin necesidad de usar un bridge. Otro uso es para el caso de una red Wifi que no soporta WDS y tenemos un nodo que enlaza a varios equipos Ethernet con la red Wifi y los equipos quieren usar direcciones IP v치lidas en la red Wifi en lugar de NAT para ser accesibles sin tener que hacer mapeos de puertos. T칤picamente esto se hace dando la misma IP a la interfaz Wifi y la Ethernet, pero poniendo el enrutado de toda la red por la Wifi salvo los nodos concretos (a los que se acceder치 en la red Wifi gracias a proxyARP) que se pondr치 una ruta concreta usando "dev" a la interfaz ethernet. </P
><P
>En general podemos ver a proxyARP como una alternativa a tener un bridge, para usarlo con tr치fico IP y hacerlo con una 칰nica IP o unas pocas.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN142"
>2.2.5. ipalias</A
></H2
><P
>Una caracter칤stica interesante de Linux es que un dispositivo de red Ethernet puede tener m치s de una IP, puede tener cuantas direcciones queramos. De este modo con una 칰nica tarjeta es posible tener varios servidores en el mismo puerto y m치quina (por ejemplo varios servidores de correo, que obligatoriamente usan el puerto 25), usando cada uno una IP distinta, sin necesidad de comprar m치s tarjetas.</P
><P
>As칤, si tenemos la interfaz eth0 con la IP 192.168.1.1 y queremos tener otra interfaz con la 192.168.1.2, simplemente creamos:<KBD
CLASS="userinput"
>ifconfig eth0:1 192.168.1.2</KBD
></P
><P
>Esta funcionalidad se llama ipalias.</P
><P
>No hay restricciones sobre si las Ips tienen que estar en la misma red o en redes distintas: la 칰nica restricci칩n es que seguimos teniendo s칩lo una direcci칩n ARP, pues esto ya es una limitaci칩n del hardware de la tarjeta, para que la tarjeta pudiera tener m치s de una MAC, tendr칤a que ponerse en modo promiscuo, con la consiguiente p칠rdida de eficiencia: el hardware de la tarjeta est치 optimizado para filtrar los paquetes que no van a su MAC ni a ninguna de las de difusi칩n. </P
><P
>T칠cnicamente una interfaz ipalias aunque con ifconfig aparezca como un dispositivo m치s, no es un dispositivo reconocido por el sistema operativo al mismo nivel que los reales ni los virtuales creados con TUN/TAP. Por ejemplo no tiene entrada espec칤fica en /proc/sys/net/ipv4/conf. Esto provoca que no funcione tratar de obtener una direcci칩n de un servidor DHCP con dhcpclient: falla cuando intenta abrir un socket raw sobre este dispositivo. T칠cnicamente nada impide que una tarjeta de red obtenga m치s de una IP, pues como dhcp-client-identifier no tiene por qu칠 usar su direcci칩n MAC, por lo que usa soluci칩n ser칤a un programa que obtenga una segunda direcci칩n, utilizando eth0. Una soluci칩n que ofrece dhcpclient es usar "interface" para obtener la IP de eth0 y para la de eth0:1 usar la directiva "pseudo", teniendo que proporcionar adem치s un script para configurar eth0:1 con la IP obtenida. Para m치s informaci칩n, ver man dhclient.conf.</P
><P
>Ojo, no usar como alias "eth0:0", pues el alias acabado en ":0" lo reserva precisamente dhclient para la opci칩n "alias", que es para asignar otra IP est치tica a una interfaz mediante ipalias, para posibles usos en entornos de movilidad donde se requiera tambi칠n una IP que no cambie con la ubicaci칩n.</P
><P
>De todos modos la mejor opci칩n es usar otro cliente de DHCP, en concreto udhcp, que s칤 pemite trabajar con interfaces creadas con ipalias.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN152"
>2.2.6. NAT trasversal</A
></H2
><P
>El NAT provoca sobre todo dos tipos de problemas:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Que la IP y puerto vayan dentro del payload del paquete, por lo que no concordar치 con el de las cabeceras IP que se modifican en el NAT. Este problema se da por ejemplo con SIP.</P
></LI
><LI
><P
>Que haya NAT en los dos lados, por lo que ninguna de las dos partes puede ser la parte que acepta la conexi칩n entrante.</P
></LI
></OL
><P
>Para el primer problema una posible soluci칩n es que en la m치quina que hace NAT exista un m칩dulo que reconoce ese protocolo y modifica tambi칠n esos contenidos dentro del payload del paquete. Es lo que se conoce como un ALG (Application Layer Gateway). Un problema de los ALG es que en protocolos complejos como SIP limitan el protocolo y que funcionen posibles extensiones. Otro problema es que un ALG est치 funcionando como un "man in middle" que manipula el paquete, por lo tanto no funcionar치 si por ejemplo la aplicaci칩n est치 usando TLS para evitar manipulaciones.</P
><P
>Otro tipo de soluci칩n es utilizar un servidor STUN (creado para UDP, aunque hay alguna extensi칩n para TCP). El cliente detr치s del NAT conecta con el servidor STUN para conecer la IP y puerto por el que sale. Esto puede resolver adem치s el segundo problema con un tipo de dispositivos NAT, en los que el mapeo al puerto es el mismo dependiendo del puerto destino y no de la IP destino. Linux no hace este tipo de NAT, pero s칤 facilita las cosas utilizando el mismo puerto de origen si est치 libre.</P
><P
>Otro tipo de servidores son los TURN, que hacen relay y por lo tanto son como redirectores. El problema es que mientras que un servidor STUN s칩lo se usa para establecer la conexi칩n, un servidor TURN se utiliza durante toda la conexi칩n para enviar todo el tr치fico a trav칠s suyo.</P
><P
>ICE es un mecanismo, originalmente creado para SIP, que consiste en probar distintas v칤as y m칠todos de conexi칩n (conexi칩n directa por cada interfaz, conexi칩n v칤a STUN, conexi칩n v칤a TURN) y entre los "candidatos" que tengan 칠xito se escoge al que se haya dado la mayor prioridad (normalmente a TURN es la que menos, luego STUN). Jingle, en Jabber (es tanto una especificaci칩n como una librer칤a), utiliza tambi칠n ICE<A
NAME="AEN164"
HREF="#FTN.AEN164"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
>.</P
><P
>Otras soluciones pasan por modificaciones en la m치quina que hace NAT (el middlebox), que permita por ejemplo a un programa pedir que se abran puertos o que le asigne un rango de puertos dentro de una IP p칰blica, pero ninguna de estas soluciones son universales (una buena referencia es la p치gina sobre NAT trasversal de la wikipedia, la versi칩n en ingl칠s). Algunas de ellas se mencionan en el apartado sobre Zeroconf y UPnP de este manual. Cabe esperar que alg칰n d칤a salgo algo m치s est치ndar de un grupo de trabajo del IETF como midcomm. Otra posibilidad interesante y antigua es SOCKS, que tambi칠n permite abrir puertos. El atractivo de todas estas soluciones frente a STUN/TURN/ICE es que se basan en la colaboraci칩n con la pol칤tica de seguridad de la empresa, no en tratar de abrir un agujero en el cortafuegos.</P
><P
>Para IPsec una soluci칩n espec칤fica es NAT-T, pero por ejemplo en Windows XP SP2 hay que activarla editando el registro<A
NAME="AEN168"
HREF="#FTN.AEN168"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
>.</P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notas</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN116"
HREF="x110.html#AEN116"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>En concreto, las redes reservadas para uso privado est치n fijadas por el RFC 1918 y son 10.0.0.0/8, 172.16.0.0/12 (es decir, de 172.16.0.0 a 172.31.255.255 y 192.168.0.0/16. Hay m치s rangos reservados para usos especiales, por ejemplo 169.254.0.0/16 para link-local o 224.0.0.0/4 para Ipv4 multicast.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN129"
HREF="x110.html#AEN129"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Protocolos de frontera interior son los que se usa para enrutar el tr치fico dentro de la organizaci칩n que tiene asignado un rango de Ips y es responsable cara a Internet de su enrutamiento (t칤picamente un proveedor de Internet, o por ejemplo RedIris), que es lo que se conoce como un AS (Autonomus System) mientras que los protocolos de frontera exterior son para enrutar entre AS.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN164"
HREF="x110.html#AEN164"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Maemo usa tambi칠n libjingle y cuenta con un documento introductorio sobre NAT-T interesante: http://maemo.org/development/documentation/how-tos/4-x/how_to_use_stun_in_applications.html</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN168"
HREF="x110.html#AEN168"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>En este SP Microsoft desactiv칩 NAT-T por defecto, por considerar un caso que podr칤a ser un riesgo de seguridad. Esta decisi칩n es muy discutida, pues no todo el mundo ve ese supuesto y consideran m치s inseguras las alternativas que ofrece a IPsec la propia Microsoft.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c49.html"
ACCESSKEY="P"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x170.html"
ACCESSKEY="N"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Paquetes de red. Modelo en Capas</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c49.html"
ACCESSKEY="U"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Capa de transporte (Layer4)</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>