<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Paquetes de red. Modelo en Capas</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="GNU/Linux, software libre para la comunidad universitaria"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Distribuciones GNU/Linux para servidores de red"
HREF="c22.html"><LINK
REL="NEXT"
TITLE="Capa de red: capa IP (Layer3)"
HREF="x110.html"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GNU/Linux, software libre para la comunidad universitaria: Redes privadas virtuales en GNU/Linux</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c22.html"
ACCESSKEY="P"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x110.html"
ACCESSKEY="N"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="AEN49"
></A
>Cap狎ulo 2. Paquetes de red. Modelo en Capas</H1
><P
>Para entender los conceptos avanzados de redes, es muy 칰til tener presente el modelo en capas de las redes. Cada capa da servicio a la capa superior implementando una funcionalidad. A la hora de enviar un paquete, la capa superior pasa a la que est치 debajo los datos que quiere enviar, quien har치 lo propio con la capa inmediatamente inferior, tras a침adir sus propias cabeceras. Al recibir un paquete los pasos son los inversos, cada capa tras interpretar y eliminar sus cabeceras pasar치 el resto de datos a la capa inmediatamente superior.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Layer 1: capa f칤sica. Nos basta saber que existe: se implementa enteramente en hardware. No nos detendremos m치s en ella. Es a partir de la capa 2 d칩nde podemos ver los paquetes con un sniffer.</P
></LI
><LI
><P
>Layer 2: capa de enlace de datos/acceso de red: Depende del tipo de red local o comunicaci칩n punto a punto que utilicemos: por ejemplo si es una Ethernet, una FDDI (red metropolitana de fibra 칩ptica, muy usada para unir los centros de las facultades o los edificios en un parque tecnol칩gico), una conexi칩n PPP sobre una l칤nea telef칩nica... En la actualidad un administrador de red raramente maneja otro enlace de datos distinto de Ethernet, pues aunque se trate de un router que conecta con otros routers v칤a FDDI, normalmente se usa un transceptor de fibra al que la conexi칩n es v칤a Ethernet y la comunicaci칩n es realmente a nivel Layer3. Lo mismo ocurre con el enlace punto a punto utilizado para el ADSL, podr치 usar PPPoA o PPPoE (un poco m치s eficiente usar PPPoA), pero lo normal es que eso sea en el router ADSL y la comunicaci칩n hasta el router ADSL es v칤a ethernet y de nuevo a nivel IP (layer3), aunque cuando el router ADSL est치 en modo monopuesto s칤 se suele utilizar un cliente PPPoE. A nivel usuario, esta capa puede presentar la dificultad de configurar un acceso Wifi o una conexi칩n Bluetooth. La capa 2 es la m치s alta que ven los bridges, switchs y hubs.</P
></LI
><LI
><P
>Layer 3: capa de red. La capa IP. Es la capa m치s alta que ven los routers. Sobre una red Ethernet puede haber m치s de una red IP, si los rangos de direcciones no se solapan o incluso pueden mezclarse distintos tipos de redes, por ejemplo una red IP con una AppleTalk o IPX (Netware).</P
></LI
><LI
><P
>Layer 4: capa de trasporte: TCP,UDP... En esta capa y en la 5, s칩lo suelen intervenir el nodo origen y destino, aunque se puede ver afectado por ejemplo por un router que haga NAT. Es la capa con la que suelen trabajar los aplicaciones, a trav칠s de sockets. En Unix los sockets se manejan como ficheros.</P
></LI
><LI
><P
>Layer 5: capa de aplicaci칩n: HTTP, MAIL, JABBER... En ocasiones esta capa se menciona como l7 (layer7) porque en el modelo de referencia OSI hay otras dos capas entre la capa de transporte y la de aplicaci칩n: sesi칩n y presentaci칩n.</P
></LI
></OL
><P
>La mayor칤a de las aplicaciones utilizan protocolos IP y para ellos las capas 1 y 2 son transparentes, como si no existieran. Sin embargo hay protocolos que se implementan directamente sobre la capa2.</P
><P
>A veces sobre la capa de red, la de transporte o incluso sobre la capa de aplicaci칩n se encapsula otro paquete desde la capa de red o incluso desde la f칤sica. El motivo es hacer t칰neles y se usa mucho en las redes privadas virtuales: se hace que dos nodos que no est치n en la misma red local se comporten como si lo estuvieran, gracias a que hemos cargado los paquetes sobre otros paquetes que van por Internet y en destino los reconstruimos.</P
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN65"
>2.1. Capa enlace de datos (Layer2)</A
></H1
><P
>Aunque la mayor칤a de las aplicaciones son independientes de esta capa al utilizar protocolos IP, hay excepciones, por ejemplo muchos juegos operan sobre layer2.</P
><P
>Tanto en una red Ethernet como en una Wifi, cada tarjeta tiene una direcci칩n que es 칰nica, la direcci칩n MAC (es como un n칰mero de serie que no se repite, para ello cada fabricante tiene asignado un rango de direcciones, aunque tambi칠n existen rangos para uso privado). Son 48 bits, o lo que es lo mismo, 12 caracteres hexadecimales. Suelen representarse as칤: 00:09:6C:EF:E4:69.</P
><P
>Las direcciones MAC al ser 칰nicas en principio se pueden usar para filtrar paquetes en un cortafuegos o para restringir el acceso en un Access Point Wifi. Error. Lo m치s probable es que nuestra tarjeta nos permita cambiar la direcci칩n ARP con un simple ifconfig eth0 hw ether 00:09:6c:EF:e4:69. Este cambio es temporal, dura hasta que lo volvamos a cambiar o reiniciemos la m치quina. Adem치s en muchas tarjetas se puede hacer el cambio permanente, pues la direcci칩n MAC se escribe en una memoria flash dentro de la tarjeta. En este caso la herramienta a utilizar se llama ethertool y la opci칩n que cambia la MAC es phyad.</P
><P
>El hardware de las tarjetas de red y de los hubs no sabe nada de direcciones IP, lo 칰nico que entiende es el formato de los paquetes ethernet, con sus direcciones MAC. </P
><P
>Es un error pensar que las tramas Ethernet se generan en el hardware o en el sistema operativo sin posibilidad de manipulaci칩n. En GNU/Linux mediante los sockets RAW (ver man 7 packet) es posible escribir tramas Ethernet. As칤 mismo mediante TUN/TAP tanto en GNU/Linux como en la mayor칤a de los sistemas operativos es posible leer/escribir a trav칠s de un dispositivo tanto tramas ethernet como paquetes IP. Si en nuestra red existe un t칰nel (por ejemplo para hacer una VPN) es posible generar paquetes Ethernet en un equipo remoto, enviarlos v칤a Internet y que un nodo en la red local los emita como si hubieran sido generados localmente.</P
><P
>En una red Ethernet para unir los distintos equipos se usa un hub o un switch. Un hub opera a nivel f칤sico y es muy primitivo: no deja de ser el equivalente en conectores de red a un "ladr칩n" en clavijas para enchufes. Tambi칠n se le compara con un repetidor. El problema de los hubs es que este modelo es poco escalable cuando existen muchos equipos en una red (especialmente si se enlazan varias redes locales f칤sicamente para no usar enrutadores, simplificando la configuraci칩n de la red y que funcionen servicios que usan broadcast a nivel Ethernet como DHCPD (en realidad tambi칠n se puede tener un 칰nico servidor para varias subredes no conectadas a nivel de enlace de datos si se usa un bootp/DHCPD agent relay), o est칠 disponible funcionalidad como wake-on-lan o servicios de autoconfiguraci칩n PnP). Un hub es poco escalable porque lo que se hace es transmitir para cada nodo todos los paquetes.</P
><P
>La alternativa a los hub son los switchs. La diferencia entre un hub y un swtich es que el segundo analiza las tramas ethernet que pasan por 칠l; si ve que un paquete ha entrado por un puerto (cada conector para un cable de red es un puerto) registra la direcci칩n MAC de origen junto con el puerto en una tabla llamada CAM, de modo que si llega un paquete para esa direcci칩n no lo env칤a por todos los puertos sino s칩lo por ese. Hoy en d칤a si vamos a una tienda a comprar un hub, lo normal es que ya no lo tengan y s칩lo vendan switchs.</P
><P
>En una red local Ethernet pueden coexistir paquetes de distintos protocolos, por ejemplo tr치fico IP y tr치fico AppleTalk. Tambi칠n es posible que sobre una misma red Ethernet haya m치s de una subred IP: si los rangos no se solapan tampoco habr치 problemas. </P
><P
>En redes de capa2 existe la posibilidad de crear varias VLAN (virtual LAN: 802.Q), que consiste en a침adir a los paquetes Ethernet una cabecera adicional que indica la LAN virtual que se aplica: un switch que soporte VLAN (los baratos no lo hacen, pero s칤 lo soporta por ejemplo los switchs de los AP que usan OpenWRT; en cualquier caso tiene que ser un switch administrable de alguna forma) s칩lo transmitir치 por un puerto los paquetes que vayan a esa VLAN (esta asociaci칩n la hace y deshace el administrador). Se puede configurar un puerto para recibir paquetes destinados a m치s de una VLAN (trunk port). La VLAN marcada como "nativa" para un puerto implica que los paquetes que van para esa VLAN se les quita el "tag" que indica la VLAN, por lo que ser칤an paquetes Ethernet normales.</P
><P
>Mediante una VLAN los paquetes broadcast s칩lo son a nivel de esa VLAN y ser칤a posible que hubiera dos redes usando el mismo cableado con rangos de Ips solapadas, si usan distintas VLANs. Podemos ver las VLANs como una forma de tener m치s de una red de capa2 sobre una 칰nica infraestructura de cableado (es decir, multiplexar varias redes de nivel 2 sobre una). Las VLANs funcionan no s칩lo sobre una red local "f칤sica", sino sobre toda una infraestructura de redes unidas por swtichs en un campus, por ejemplo. </P
><P
>T칤picamente se hacen coincidir las VLANs con las subredes IP de capa 3. De este modo se fuerza a usar enrutamiento para comunicarse entre nodos de distinta subred. Un ejemplo de uso de VLANs es la infraestructura de red de una empresa, d칩nde es necesario aislar las redes de distintos proyectos, pero sin que haga falta relocalizar los ordenadores de los programadores y de los servidores</P
><P
>Hay un identificador reservado para paquetes que no pertenecen a ninguna VLAN, el cero. El uno tambi칠n est치 reservado, para gesti칩n</P
><P
>En GNU/Linux el comando para crear redes VLAN es vconfig.</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN80"
>2.1.1. WDS</A
></H2
><P
>A la hora de tratar de hacer un bridge entre una tarjeta Ethernet y una tarjeta Wireless nos podemos encontrar con que no funciona. El motivo es que para que funcione un bridge los paquetes Wifi tienen que incluir hasta 4 direcciones: la direcci칩n MAC origen, la direcci칩n MAC de la tarjeta Wifi, la direcci칩n MAC del Access Point, la direcci칩n MAC destino. Si la tarjeta (m치s que su hardware el driver no tiene en cuenta estas 4 direcciones sino 3 (todas menos la origen, al suponer que la origen es la de la tarjeta) no funcionar치. Lo mismo ocurrir치 si el AP no reconoce las 4 direcciones. Con un bridge que s칩lo afecta a tarjetas Ethernet no hay este problema: s칩lo hay direcci칩n origen y destino, las tarjetas del bridge se ponen en modo promiscuo para recibir todos los paquetes y no s칩lo los de su MAC, por lo que la direcci칩n de las tarjetas que forman el bridge no van en el paquete al no hacer falta.</P
><P
>Para que una conexi칩n Wifi pueda participar en un bridge, la tarjeta por lo tanto tiene que soportarlo y el AP tambi칠n: los AP que soportan WDS son aptos. WDS (Wireless Distribution System) permite implementar un bridge entre dos AP ampliando la cobertura al alcance de los dos.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN84"
>2.1.2. IEEE802.1X</A
></H2
><P
>Es un sistema para autenticar un puerto (f칤sico) en un dispositivo de red, por ejemplo lo ofrecen algunos switch avanzados y los Access Point Wifi. La idea es que el cliente (por ejemplo un PC) que se conoce es el supplicant y el dispositivo de red es el authenticator que tiene que autorizarle. T칤picamente el authenticator contacta con un servidor Radius<A
NAME="AEN87"
HREF="#FTN.AEN87"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>. Para autenticar se utiliza AEP.</P
><P
>Windows incluye software supplicant y en el caso de Linux hay dos programas: Xsupplicant, que sirve para todo tipo de hardware y wpa-supplicant, que es espec칤fico para Wifi.</P
><P
>Autenticarse mediante IEEE802.1X no evita todos los ataques posteriores derivados de insertar un hub entre la m치quina y el switch, pues la autenticaci칩n s칩lo es al principio: ser칤a conveniente usar adem치s IPsec (en el caso del Wifi la conexi칩n tras autenticarse va cifrada luego ya ser칤a segura).</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN91"
>2.1.3. WEP/WPA/WPA2/IEEE802.11i/</A
></H2
><P
>En las redes Wifi sobre la capa 2 se implement칩 cifrado mediante WEP. Sin embargo este m칠todo se ha demostrado muy inseguro.<A
NAME="AEN94"
HREF="#FTN.AEN94"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
>. La soluci칩n de compromiso utilizando el mismo hardware (cifrado de flujo con RC4) es WPA, que cambia din치micamente la clave (TKIP) e introduce varios mecanismos de seguridad. WPA2 (IEEE802.11i) usa AES para cifrar en lugar de RC4 (no es compatible pues con el hardware viejo) e introduce algunas otras mejoras. Tanto WPA como WPA2 admiten dos configuraciones: personal y enterprise. En personal (WPA/PSK) se usa una clave compartida, que ser치 la misma en todos los nodos, por lo que es una soluci칩n v치lida para protegerse de intrusos externos, pero no frente a ataques de personas con un nodo en la red. La versi칩n empresarial en cambio utiliza para autenticarse (y para obtener la clave de sesi칩n) IEEE802.1X. Tanto si se usa la configuraci칩n personal como la empresarial, el programa a utilizar es wpa_supplicant (para depurar posibles errores cabe conectarse a ese demonio con wpa_cli as칤 como observar con dmesg los mensajes del kernel,<A
NAME="AEN96"
HREF="#FTN.AEN96"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
> por ejemplo podemos deducir que es necesario ejecutar iwpriv eht1 host_roaming 1). En Ubuntu utilizar WPA es tan sencillo como incluir en /etc/network/interfaces unas l칤neas como estas:
<PRE
CLASS="screen"
>iface eth0 inet dhcp
wpa-ssid MIWLAN
wpa-key-mgmt WPA-PSK
wpa-passphrase mipassphrase_1asfPasfd
</PRE
>
</P
><P
>WPA a d칤a de hoy previene los ataques m치s problem치ticos que existen sobre RC4, aunque ya existen ataques que lo hacen no seguro y probablemente se descubran nuevas vulnerabilidades en el futuro, que haga que si alguien almacena hoy tr치fico WPA pueda descifrarlo dentro de a lo sumo unos a침os. WPA/PSK no es s칩lido cuando las claves de los usuarios son d칠biles o est치n en un diccionario; no facilita la prevenci칩n de este tipo de ataques. Las vulnerabilidades existentes actualmente de WPA no permiten robar ancho de banda, pero s칤 provocar problemas inyectando paquetes<A
NAME="AEN100"
HREF="#FTN.AEN100"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
>.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN102"
>2.1.4. Wakeonlan</A
></H2
><P
>Una caracter칤stica interesante que permiten la mayor칤a de las tarjetas de red actuales es encender el equipo remotamente: wake on lan. Es 칰til para tareas de mantenimiento y tambi칠n para poder conectarse al equipo desde casa en caso de necesidad, por ejemplo mientras se est치 de soporte. Esta funcionalidad se implementa mediante un paquete a nivel de enlace de datos.</P
><P
>Para que funcione esta funcionalidad, normalmente hay que activarla en la BIOS. En algunas tarjetas de red, tambi칠n hay que unir un peque침o cable que sale de la tarjeta a un conector en la placa base que pone "wake on lan". Dependiendo del caso, tambi칠n es posible que tengamos que activar la funcionalidad en la tarjeta, para eso utilizamos la herramienta ethtool. Con ethtool &#60;nombre_interfaz&#62; (por ejemplo ethtool eth0) veremos los distintos modos wake-on-lan que soporta la tarjeta, si es que soporta alguno. Con <KBD
CLASS="userinput"
>ethtool eth0 -set wol g</KBD
> activamos el modo wake-on-lan basado en "magic packet", el modo m치s habitual. Se trata de un paquete que en alguna parte debe contener un patr칩n consistente en primero 6 bytes con todos sus bits a 1, seguido por la direcci칩n MAC de la tarjeta repetida 16 veces. Opcionalmente continua con una password, que tambi칠n se fija con ethtool pero que s칩lo admiten algunas tarjetas.</P
><P
>El paquete normalmente se construye usando UDP al puerto 9 (discard) y enviando el paquete por broadcast, aunque puede ir encapsulado en cualquier tipo de paquete, ni siquiera tiene que ser IP.</P
><P
>쮼s posible despertar a un equipo mediante un "magic packet", envi치ndolo desde fuera de la red local? normalmente no, salvo que tengamos una infraestructura de VPN. El problema es c칩mo hacer llegar el paquete hasta la m치quina; si est치 conectada a un switch s칩lo recibir치 los paquetes que van destinadas a su MAC o paquetes broadcast/multicast. Es bastante frecuente que los enrutadores no dejen pasar los paquetes broadcast. Pero si intentamos la otra opci칩n, enviar el paquete a su IP, al llegar al enrutador posiblemente ya no tenga la entrada ARP, pues caducan tras un tiempo; cuando haga la petici칩n ARP no obtendr치 respuesta, pues la m치quina est치 apagada. Una forma de evitarlo es insertar est치ticamente la entrada en la tabla ARP.</P
><P
>Los dos programas m치s recomendables son wakeonlan y etherwake. Etherwake genera directamente un paquete Ethernet, por lo que requiere privilegios de root y s칩lo sirve para ejecutarlo en la propia red local.</P
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notas</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN87"
HREF="c49.html#AEN87"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Radius es un protocolo definido para hacer AAA (Authentitacion, Authorization and Accounting) usado sobre todo para los ISP. Se utiliza usuario y contrase침a, protegida con MD5 y un secreto compartido entre el servidor Radius y el NAS (Network Access Server, en este caso el authenticator, por ejemplo el Access Point, pero en el escenario m치s cl치sico es el servidor PPP del ISP), que es el cliente Radius. De todos modos hoy en d칤a los servidores Radius soportan sistemas de autenticaci칩n distintos de usuario y contrase침a para autenticar, en concreto AEP con m칠todos como AEP-TLS que implica certificados cliente y que la comunicaci칩n entre el supplicant y el servidor Radius se haga sin que el authenticator tenga que soportar cada uno de estos m칠todos AEP. La secuencia cl치sica de Radius es que el usuario se autentique con su ISP usando PPP y el servidor PPP contacte con el servidor Radius pas치ndole las credenciales que ha recibido del usuario v칤a PPP. El servidor puede asignar datos como una IP o rango de IPs, as칤 como par치metros L2TP o QoS (en realidad cualquier tipo de informaci칩n, pues como los servidores DHCP permite extensiones de vendedor) . Las funciones de Accounting b치sicamente consisten en el que el NAS pasa informaci칩n a registrar como duraci칩n de la sesi칩n o tr치fico transferido.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN94"
HREF="c49.html#AEN94"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Existen varias aplicaciones para automatizar el conseguir una clave WEP, como el ya antiguo airsnort, si bien hoy en d칤a hay programas m치s avanzados como aircrack-ng.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN96"
HREF="c49.html#AEN96"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>En algunos casos puede resistirse una configuraci칩n WPA. Una p치gina que muestra gran cantidad de opciones posibles es http://manual.sidux.com/es/internet-connecting-wpa-es.htm. Sobre WPA Enterprise y el uso de EAP, algunas referencias interesantes son  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN100"
HREF="c49.html#AEN100"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>El antes citado aircrack-np no se usa s칩lo para WEP, pues tambi칠n se usa con redes en las que se conoce la clave WPA/PSK o se trata de atacar si est치 en un diccionario. No s칩lo utiliza el modo monitor de las tarjetas sino que "inyecta" paquetes para facilitar la tarea de romper la seguridad. Aunque en general aircrack es un programa que parece dedicado a la gente que desea colarse en las redes ajenas, su utilidad airtun-ng s칤 es aprovechable en redes con WPA/PSK para usar un IDS. La web es interesante por la documentaci칩n sobre seguridad en redes Wifi.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c22.html"
ACCESSKEY="P"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x110.html"
ACCESSKEY="N"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Distribuciones GNU/Linux para servidores de red</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Capa de red: capa IP (Layer3)</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>