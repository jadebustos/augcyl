<?xml version='1.0' encoding='iso-8859-1'?>
<!-- CAPITULO 7 -->
  <chapter>
    <title>Interprete de Comandos</title>
<para>Para la relación con el sistema el administrador debe utilizar
un interface. Evidentemente en los sistemas modernos los interfaces
visuales son la principal forma de dar ordenes al ordenador, pero
en Unix y en Linux el administrador debería conocer también un
interface textual.</para>
<para>Cuando se utiliza en linea para introducir
directamente comandos se denomina shell
interactiva.</para>
<para>Para el administrador, el interprete de comandos (shell) y
"guiones" del interprete de comandos (shell scripts) son muy importantes
por varias razones:</para>
<itemizedlist>
<listitem><para>
La mayor parte de herramientas y aplicaciones están preparadas para
utilizarse
mediante la shell y los scripts.
</para></listitem>
<listitem><para>
La configuración del sistema y de la mayoría de los servicios
proporcionados se hacen mediante herramientas proporcionadas en forma
de shell scripts.
</para></listitem>
<listitem><para>
La principal forma de automatizar procesos de administración es  mediante la creación de shell scripts por parte del administrador.
</para></listitem>
</itemizedlist>
<para>También veremos algunos servicios donde se utilizan habitualmente los
shell script.</para>
    <sect1>
      <title>Shell Scripting</title>
<para>Los shell scripts son ficheros de texto que contienen comandos
de sistema, comandos propios del interprete de comandos y estructuras de control necesarias para procesar el flujo del programa (tipo while, for, etc).
Los ficheros script son directamente ejecutables por el sistema bajo el nombre que se haya dado al fichero. Para ejecutarlos, se invoca el shell junto con el nombre del fichero, o bien se dan permisos de ejecución.
</para>
<para>La programación en shell es muy útil y cómoda para crear
programas fácilmente modificables, pequeños, no complejos, que resuelvan tareas
repetitivas, típicas de los administradores. Además, es un lenguaje
preparado para manejar ristras y procesar y filtrar texto, por lo que es mucho más fácil programar en shell, que, por ejemplo, en C.</para>
      <sect2>
      <title>Algunas shells</title>
<para>Un inconveniente es que no es un lenguaje estandarizado si no
que hay varias versiones del shell.</para>
      <para>Algunos de los más comunes son:</para>
<itemizedlist>
<listitem><para>
El shell Bourne (sh). El shell estándar
   UNIX, y el que todos los UNIX poseen en alguna versión, en linux es
un bash renombrada. El sh fue creado
   por Stephen Bourne en AT&amp;T a finales de los setenta. El
prompt por defecto suele ser un '$'  y en usario root '#'.
</para></listitem>
<listitem><para>El shell Bash (bash). El shell Linux por defecto. Deriva de
      la bourne shell pero se ha impuesto en gran medida por su
      utilización en Linux.
</para></listitem>
<listitem><para>
El shell Korn (ksh). Es una mejora del Bourne, escrito en
AT&amp;T por David Korn en los años
   ochenta, intenta combinar la sencillez del Bourne
   con la eficacia de la shell C, más algún añadido. El prompt por defecto es el $.
</para></listitem><listitem><para>
El shell C (csh). Fue desarrollado en la Universidad de Berkeley
   por Bill Joy a finales de los setenta y tiene unos cuantos añadidos
   interesantes al Bourne, como un histórico de comandos, alias,
   aritmética desde la línea de comandos, completa nombres de ficheros y control de trabajos en segundo plano. El prompt por defecto para los usuarios es `%'. Una
   ventaja de los scripts en C shell es que, como su nombre indica,
   su sintaxis está basada en el lenguaje C. Como shell
posteriores recogen las mejoras de esta, hace que no se utilice mucho,
aunque todavía se encuentran muchos scripts desarrollados para esta shell.
</para></listitem><listitem><para>
Existen muchas otras que son variantes de estas, normalmente
   versiones reducidas con
   aplicaciones específicas.
</para></listitem>
</itemizedlist>
      </sect2>
      <sect2>
      <title>Creando shell scripts</title>
      <para>Cada shell cambia un poco el lenguaje pero tienen muchas
      características comunes. Vamos a ver un resumen de la sintaxis
      del lenguaje:</para>
<orderedlist>
<listitem><para>
Los comentarios se comienzan con #. En la primera linea se debe
escribir #! con la shell que (o incluso un interprete, como
perl o php) con la que queremos ejecutarla, por ejemplo:</para>
<programlisting>#!/bin/bash</programlisting>
</listitem><listitem><para>
Para realizar redirecciones de los programas se utilizan 
<userinput>&gt;</userinput> para salida, <userinput>&lt;</userinput> para
entrada, <userinput>&amp;&lt;</userinput> para salida de error y
<userinput>|</userinput>túnel (pipe).</para>
<programlisting>cat laza.txt |wc -l > lineas_laza.count</programlisting>
<para>La salida del comando <command>cat</command> que es le fichero
<filename>laza.txt</filename> se le pasa al comando <command>wc
-l</command> que cuenta las lineas y lo mete en el fichero <filename>lineas_laza.count</filename>.
</para></listitem><listitem><para>
Para definir variables se debe poner el nombre seguido de igual y su
valor. Para referenciarlas con el símbolo dolar ($). Existen variables
predefinidas, como $1 para el primer parámetro del shell script, $HOME
directorio home de usuario, $? código de salida de programa recién
ejecutado y muchas más dependiendo de la shell.</para>
<programlisting>FILE=/tmp/salida
cat laza.txt | wc -l >> $FILE</programlisting>
<para>Crea la variable FILE poniendo un nombre de fichero y la utiliza
para añadir la salida del resultado del contador de lineas.
</para></listitem><listitem><para>
Hay tres tipos de comillas, las dobles interpretan las variables que
hay dentro, las simples no, y la comilla invertida ejecuta su
contenido como un comando y lo mete en la variable.</para>
<programlisting>DATE=`date +%d-%m-%Y`;
MSG1="La fecha es $DATE";
MSG2='La variable donde guardo la fecha se llama $DATE con el comando
date +%d-%m-%Y';
echo $DATE;
echo $MSG1;
echo $MSG2;
</programlisting>
<para>Para ejecutar este script:</para>
<screen>
<prompt>[pcm@sal]# </prompt><userinput>sh comillas.sh</userinput>
<computeroutput>14-04-2007
La fecha es 14-04-2007
La variable donde guardo la fecha se llama $DATE con el comando date
+%d-%m-%Y</computeroutput>
<prompt>[pcm@sal]# </prompt>
</screen></listitem><listitem><para>
Para las shell la condición verdadera es el 0 y el resto lo interpreta
como 
falso. Existen bastantes operadores para realizar las
condiciones. Pueden hacerse condiciones sobre fichero: si es un
fichero (-f), si es un directorio (-d), si hay permiso de lectura
(-r). También sobre cadenas, sobre números y combinar condiciones. 
</para><para>Por ejemplo <userinput>[ -d .ssh -a \( -n $JDK_HOME -o -n $JAVA_HOME \) ]</userinput> nos
devolvería como verdadero si existe el directorio <filename>.ssh</filename> y alguna de las dos variables
no deben ser vacías.</para>
</listitem><listitem><para>
Para el control de flujo tenemos las estructuras
<userinput>if</userinput>, <userinput>case</userinput>,
<userinput>while</userinput>, <userinput>for</userinput>
 y <userinput>until</userinput>.
</para></listitem><listitem><para>
Existen un conjunto de herramientas que son muy utilizadas en los
shell script, como pueden ser <userinput>cut</userinput>,
<userinput>grep</userinput>, <userinput>sed</userinput>,
<userinput>awk</userinput>, <userinput>date</userinput>, etc...
</para></listitem><listitem><para>
Para hacer debug podemos chequear la sintaxis del shell script
con:</para>
<screen>
<userinput>sh -n mishell.sh</userinput></screen>
<para>También podemos hacer que nos muestre la ejecución de los
comandos que hay en el shell script y los valores que van tomando las
variables con:</para>
<screen>
<userinput>sh -x mishell.sh</userinput>
</screen>
</listitem>
</orderedlist>
</sect2>
   <sect2>
   <title>Ejemplo de un shell script</title>
      <para>Como ejemplo de programa shell script vamos a hacer una
      utilidad para buscar ficheros de texto de DOS en el directorio
      actual y preguntarnos si lo queremos convertir a fichero de texto UNIX. Los
      ficheros de texto en la plataformas DOS/Windows para finalizar
      cada linea llevan dos caracteres de control, el ascii 10 (LF) y el
      ascii 13 (CR). En cambio en UNIX, y por tanto el Linux los fichero de
      linea sólo utilizan el carácter de control ascii 10 (LF).</para>
    <para>La mayor parte de los editores de Linux ya distinguen si es
      un texto de DOS o Unix. Además existe un comando para realizar esta
      conversión, <command>dos2unix</command>. Por lo que no suele
      hacer falta una shell para esta tarea, a no ser que no
      dispongamos del conversor en el sistema. El programa sería:</para>
<programlisting>
#!/bin/bash
for fichero in *.txt; do
  if grep ^M $fichero &amp;>/dev/null; then
     resp=x
     while [ $resp != "s" -a $resp != "n" ]; do
       echo "'$fichero' es un fichero texto DOS. convertir? (s/n) "
       read resp
     done
     case $resp in
       s)
         sed 's/^M//' $fichero > /tmp/FILE_TMP
         mv /tmp/FILE_TMP $fichero
         echo "El fichero '$fichero' convertido a texto UNIX";;
       n)
         echo "El fichero '$fichero' se deja texto DOS";;
       *)
         echo "ERROR";;
     esac
   fi
done
</programlisting>
<para>Primeramente ponemos el comentario para indicar que es un script
para bash.</para>
<para>El <emphasis>for</emphasis> nos va a realizar un bucle por todos
los fichero que terminen en <filename>.txt</filename>.</para>
<para>Hacemos una condición que con el comando <command>grep</command>
nos mire si el fichero tiene lineas con carácter ascii 13 (CR). Para
introducir el carácter ^M hemos pulsado Control+V y Control+M, no se
escribe con ^ y la M. Este
comando si no encuentra
ninguna linea devuelve 1, y si encuentra al menos una linea devuelve
cero, con lo cual cumplimos la condición.</para>
<para>A continuación vamos a pedir al usuario que nos confirme la
conversión. Para ello ponemos por pantalla la pregunta y con el
comando <command>read</command> cogemos el valor introducido. Con un
<emphasis>while</emphasis> insistimos con la pregunta mientras la
contestación no sea s o n.</para>
<para>Con <emphasis>case</emphasis> comprobamos que ha metido. Sería
más lógico hacerlo con un <emphasis>if else</emphasis>, pero así vemos
está estructura. Sí selecciono <emphasis>n</emphasis> se imprime por
pantalla que no se hizo nada con el fichero.</para>
<para>Cuando opto por convertir el fichero utilizamos la herramienta
<command>sed</command> que mediante expresiones regulares nos permite
hacer sustituciones dentro de un fichero de texto. En este caso le
estamos diciendo que sustituya los CR por nada. La salida la
redirigimos a un fichero temporal que luego sustituye al
original.</para>
<para>Para ejecutar el programa tendríamos dos posibilidades, o bien
lo hacemos ejecutable con el comando <command>chmod u+w
txtunixdir.sh</command> y luego lo arrancamos como
<command>./txtunixdir.sh</command> o bien le pasamos a una shell como
parámetro nuestro programa:</para>
<screen>
<prompt>[pcm@sal]# </prompt><userinput>sh txtunixdir.sh</userinput>
<computeroutput>cursos.txt' es un fichero texto DOS. convertir? (s/n)</computeroutput>
<userinput>n</userinput>
<computeroutput>El fichero 'cursos.txt' se deja texto DOS
'lazae11.txt' es un fichero texto DOS. convertir? (s/n)</computeroutput>
<userinput>s</userinput>
<computeroutput>El fichero 'lazae11.txt' convertido a texto UNIX</computeroutput>
<prompt>[pcm@sal]# </prompt>
</screen>
<para>Si al escribir el programa nos hubiésemos dejado sin poner los
dos puntos y coma en las opciones del <emphasis>case</emphasis>
tendríamos un error, que antes de ejecutar nos lo advertiría.</para>
<programlisting>
...
  n)
    echo "El fichero '$fichero' se deja texto DOS"
...
</programlisting>
<para> Si solo
queremos comprobar sin ejecutar lo podríamos hacer con la opción
-n.</para>
<screen>
<prompt>[pcm@sal]# </prompt><userinput>sh -n txtunixdir.sh</userinput>
<computeroutput>txtunixdir.sh: line 16: syntax error near unexpected token `)'
txtunixdir.sh: line 16: `       *)'</computeroutput>
<prompt>[pcm@sal]# </prompt>
</screen>
<para>Corregimos de nuevo, y ahora ejecutamos pero con la opción
-x.</para>
<screen>
<prompt>[pcm@sal]# </prompt><userinput>sh -x txtunixdir.sh</userinput>
<computeroutput>+ grep $'\r' cursos.txt
+ resp=x
+ '[' x '!=' s -a x '!=' n ']'
+ echo ''\''cursos.txt'\'' es un fichero texto DOS. convertir? (s/n) '
'cursos.txt' es un fichero texto DOS. convertir? (s/n)
+ read resp</computeroutput>
<userinput>s</userinput>
<computeroutput>+ '[' s '!=' s -a s '!=' n ']'
+ sed $'s/\r//' cursos.txt
+ mv /tmp/FILE_TMP cursos.txt
+ echo 'El fichero '\''cursos.txt'\'' convertido a texto UNIX'
El fichero 'cursos.txt' convertido a texto UNIX
+ grep $'\r' iptables.txt
+ grep $'\r' lazae11.txt</computeroutput>
<prompt>[pcm@sal]# </prompt>
</screen>
    </sect2>
    </sect1>
    <sect1>
      <title>Planificación de Tareas</title>
      <para>Es muy normal que queramos que nuestros shell script se
      ejecuten periódicamente o en un determinado momento. Tareas como
     la realización de backups, borrado de temporales, seguridad se
      deben planificar mediante estos comandos. Existen unos
      servicios para temporizar estos trabajos.</para>
<!-- Manual de jadebustos capitulo 10 -->
        <sect2>
        <title><application>at</application></title>
        <para>Mediante el comando at podemos lanzar nuestros procesos
        a un tiempo determinado sin necesidad de estar conectados en
        ese momento.</para>
<para>Para realizar una ejecución de un script de backup a las 10 de
        la mañana haríamos:</para>
<screen><prompt>[pcm@sal]$ </prompt><userinput>at 10am &lt; backup.sh</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 11 at 2007-04-01 10:00</computeroutput>
<prompt>[pcm@sal]$ </prompt><userinput>atq</userinput>
<computeroutput>10      2007-04-01 01:00 a pcm
11      2007-04-01 10:00 a pcm
</computeroutput><prompt>[pcm@sal]$ </prompt>
</screen>
<para>Con el comando <userinput>atq</userinput> vemos la lista de
los procesos pendiente de ejecutarse. Es equivalente utilizar
<userinput>at -l</userinput>.</para>
<para>Si queremos evitar que se ejecute el comando programado podemos
borrar la entrada con <userinput>atrm</userinput> indicando el
número de trabajo.</para>
<screen><prompt>[pcm@sal]$ </prompt><userinput>atrm 10</userinput>
<computeroutput></computeroutput>
<prompt>[pcm@sal]$ </prompt><userinput>at -l</userinput>
<computeroutput>11      2007-04-01 10:00 a pcm
</computeroutput><prompt>[pcm@sal]$ </prompt>
</screen>
<para>El proceso <userinput>atd</userinput> se encargará de ejecutar
        nuestra orden en el momento programado.</para>
<para>Existe variante, realmente un script, que permite lanzar nuestra
        orden solo si la carga del sistema es lo suficientemente baja,
        configurada en la ejecución de servicio.</para>
<para>Para configurar los usuarios que tienen permisos para utilizar
        el comando <userinput>at</userinput> existen dos ficheros
        <filename>/etc/at.allow</filename> y
        <filename>/etc/at.deny</filename>. En la ejecución del comando
        se comprueba:</para>
<orderedlist>
<listitem><para>
Si existe <filename>/etc/at.allow</filename> y el usuario que ejecuta
el comando <application>at</application> o
<application>batch</application> está en el fichero se permite
ejecución.
</para></listitem>
<listitem><para>
Si no existe <filename>/etc/at.allow</filename> y existe
<filename>/etc/at.deny</filename>, se comprueba que el usuario que ejecuta
el comando no este en el fichero, para permitirle.
</para></listitem>
<listitem><para>Si no existen ninguno de los dos fichero, solo root
puede utilizar el comando.
</para></listitem>
</orderedlist>
        </sect2>
<sect2>
        <title><application>cron</application></title>
        <para>Este servicio nos permite dejar las tareas
        programadas. Con el comando <application>at</application>
        teníamos que estar lanzando el comando por cada ejecución, con
        <application>cron</application> dejamos ya programado cuando y cada
        cuanto queremos esa ejecución.</para>
<para>Es uno de los principales recursos de administración ya que como
        ya hemos comentado las tareas de administración suele ser
        repetitivas y periódicas, por lo que con este servicio vamos a
        poder programarlas a nuestro antojo.</para>
<para>El proceso que controla el servicio, es decir, que ejecuta las
        tareas programadas es <userinput>cron</userinput>, y para
        realizar nuestras programaciones debemos utilizar el comando
        <userinput>crontab</userinput>.</para>
<para>Para listar tareas utilizaremos <userinput>crontab
        -l</userinput>.</para>
<screen><prompt>[pcm@sal]$ </prompt><userinput>crontab -l</userinput>
<computeroutput>*/10 10-19 * * * /root/adsl/vpn.sh >> /root/adsl/vpn.log 2>&amp;1
</computeroutput>
<prompt>[pcm@sal]$ </prompt>
</screen>
<para>Vemos que por cada tarea hay una serie de parámetros que debemos
entender:</para>
<itemizedlist>
<listitem><para>
La primera columna indica el minuto en que se ejecuta, pueden
indicarse varios separándolos por comas, por ejemplo 15,30,45, o un
rango separando dos valores por un guión. Poniendo el * indicamos que
todos los minutos. También
se puede indicar cada cuanto, poniendo */2, se ejecutaría cada 2
minutos. Los
valores serán entre 0 y 59.
</para></listitem>
<listitem><para>
En la segunda columna indicamos la hora. Igualmente se pueden indicar varias
horas separadas por comas, rangos, asterisco y fracciones. Los valores son entre
0 y 23.
</para></listitem>
<listitem><para>
La tercera columna nos indica el día del mes. Los valores pueden ser
entre 1 y 31.
</para></listitem>
<listitem><para>
La cuarta nos indica el mes. Los valores son entre 1 y 12, y también
se admiten nombres de meses.
</para></listitem>
<listitem><para>
La quita nos indica el día de la semana. Los valores pueden ser entre
0 y 7, siendo el domingo 0 o 7. También admiten los nombres.
</para></listitem>
<listitem><para>
Por último siempre tendremos el comando a ejecutar.
</para></listitem>
</itemizedlist>
<para>Para crear una nueva tarea utilizaremos o modificar las que
tenemos <userinput>crontab
        -e</userinput>, que abrirá un editor con las tareas actuales
        para que modifiquemos o creemos una nueva.</para>
<screen><prompt>[pcm@sal]$ </prompt><userinput>crontab -e</userinput>
<computeroutput>*/10 10-19 * * * /root/adsl/vpn.sh >> /root/adsl/vpn.log 2>&amp;1
~
~
~
~
</computeroutput>
</screen>
<para>Al igual que el comando <userinput>at</userinput> la seguridad
        de utilización del servicio se realiza mediante los ficheros
        <filename>/etc/cron.allow</filename> y
        <filename>/etc/cron.deny</filename>. Tenemos que tener en
        cuenta de nuevo:</para> 
<orderedlist>
<listitem><para>
Si existe <filename>/etc/cron.allow</filename> y el usuario que ejecuta
el comando <application>cron</application> está en el fichero se permite
la programación.
</para></listitem>
<listitem><para>
Si no existe <filename>/etc/cron.allow</filename> y existe
<filename>/etc/cron.deny</filename>, se comprueba que el usuario que ejecuta
el comando no este en el fichero, para permitirle.
</para></listitem>
<listitem><para>Si no existen ninguno de los dos fichero, solo root
puede utilizar el comando.
</para></listitem>
</orderedlist>
        </sect2>
        <sect2>
        <title><application>anacron</application></title>
        <para>Este comando esta pensado para la automatización de
        tareas cuando el sistema no esta disponible las 24 horas del
        día.</para>
<para>Con el servicio <application>cron</application> si en la
        programación de una tarea el sistema no esta encendido, la
        tarea no se realizara. Con <application>anacron</application>
        podemos indicar cada cuanto se realizan ciertas tareas y se
        encarga de que se lleve acabo con esa frecuencia.</para>
<para>Nos permite configurar las tareas por días, lo normal es que
        tengamos tareas diarias, semanales (7) o mensuales (30), pero
        no nos asegura el horario de ejecución, únicamente cuando se
        inicia el sistema y vea que han pasado esa serie de días
        ejecutará la tarea.</para>
        </sect2>
    </sect1>
  </chapter>
