<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Acceso remoto seguro</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="GNU/Linux, software libre para la comunidad universitaria"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Servidor Jabber"
HREF="x314.html"><LINK
REL="NEXT"
TITLE="Redes Privadas Virtuales (VPN)"
HREF="c380.html"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GNU/Linux, software libre para la comunidad universitaria: Redes privadas virtuales en GNU/Linux</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x314.html"
ACCESSKEY="P"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c380.html"
ACCESSKEY="N"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="AEN347"
></A
>Cap狎ulo 5. Acceso remoto seguro</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN349"
>5.1. Distintas soluciones de acceso remoto</A
></H1
><P
>Para conectarse desde casa o desde otra ubicaci칩n a la red del trabajo, hay distintas alternativas:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Usar una VPN, de modo que nuestro ordenador de casa virtualmente est칠 en la red de la empresa, pero a trav칠s de una conexi칩n cifrada v칤a Internet. Esta es la opci칩n m치s potente, pero tambi칠n la m치s compleja. Una empresa que tenga una pol칤tica estricta de seguridad sobre las m치quinas instaladas en la red, con el filtrado de red, se encontrar치 con que cada vez que se conecte el usuario se a침ade a su red local un nodo que puede estar en una red insegura (aunque esto depende tambi칠n de la configuraci칩n, un equipo puede conectarse a la red remota y desconectarse del resto). Es una opci칩n especialmente interesante cuando el usuario usa un port치til tanto cuanto est치 en la empresa como en su casa.</P
></LI
><LI
><P
>Conectarnos remotamente a nuestro escritorio del PC del trabajo, usando un t칰nel con SSH (tambi칠n se puede hacer con SSL), con lo que s칩lo habr칤a que abrir un puerto en el cortafuegos de la empresa. Es una soluci칩n m치s conservadora, pues virtualmente el usuario est치 usando su monitor, teclado y rat칩n para acceder a la m치quina del trabajo, pero por ejemplo no puede ni transferir ficheros entre su equipo local y el de la oficina (aunque algunas soluciones de escritorio remoto s칤 lo permiten) o conectarse desde su equipo de casa a ning칰n servicio. Para el usuario tambi칠n es una soluci칩n sencilla, pues est치 usando su equipo de la oficina en el que ya est치 todo el software instalado y configurado. Sin embargo no es una soluci칩n id칩nea si por ejemplo el usuario tiene que escribir un documento y luego enviarlo: para eso ser칤a m치s razonable que lo pueda editar en su equipo y conectarse a la intranet de la empresa. Adem치s esta posibilidad no est치 disponible cuando el trabajador que se conecta remotamente no tiene un PC de sobremesa en la oficina sino que usa un port치til que se lleva a casa. </P
><P
>T칠cnicamente usando SSH se pueden abrir m치s t칰neles para por ejemplo acceder a la web interna o transferir ficheros, pero eso ya supone mayor conocimiento por parte de los usuarios y es as칤 mismo posible limitar estas posibilidades. De todos modos en el momento que se permite al usuario crear un t칰nel cifrado potencialmente se le est치 dando acceso total a la red local de la empresa, pues el usuario puede utilizar el t칰nel para encapsular lo que quiera, incluyendo por ejemplo una sesi칩n PPP para implementar as칤 una VPN completa.</P
></LI
><LI
><P
>Usar lo que se ha dado en llamar, no con demasiada propiedad, SSL VPN. Es el caso del programa SSLExplorer Community Edition. Este tipo de soluci칩n es intermedia entre las dos anteriores. Ofrece una interfaz web, que completada con c칩digo Java permite navegar por el disco duro de la m치quina remota, transferir ficheros entre las dos m치quinas, navegar por la intranet de la empresa... Se implementa tambi칠n con un t칰nel SSL y permite crear t칰neles para distintas aplicaciones y lanzar la aplicaci칩n en cuesti칩n, por ejemplo rdesktop para conectarse a un escritorio remoto de Windows.</P
><P
>Un detalle de nomenclatura, es que OpenVPN se define tambi칠n como una SSL VPN pero no tiene nada que ver con esto, puesto que es una VPN real, que permite todo lo que ofrece cualquier otra VPN, mientras que las aplicaciones como SSLExplorer no son realmente VPNs. Se define como SSL VPN porque la VPN se encapsula en un t칰nel SSL y s칩lo hay que abrir un puerto.</P
></LI
></OL
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN361"
>5.1.1. Una soluci칩n pr치ctica: crear un t칰nel con openSSH<A
NAME="AEN363"
HREF="#FTN.AEN363"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></A
></H2
><P
>Supongamos que queremos conectarnos desde casa con el puerto 8080 en la m치quina 192.168.1.100 de la red local de nuestra empresa. Para ello contamos con una m치quina SSH que est치 dentro de la red local de la empresa y a la que llegamos a trav칠s de un DNAT que hemos hecho en el cortafuegos. En este caso hemos abierto el puerto 34321 del cortafuegos, que tiene la IP p칰blica 87.15.10.120: los paquetes con este destino cambiar치n de 87.15.10.120 a 192.168.1.1:22. As칤 pues, cuando nos conectemos v칤a ssh a 87.15.10.120:34321, llegamos en realidad al puerto SSH de 192.168.1.1.</P
><P
>La soluci칩n est치 en utilizar la posibilidad que ofrece SSH de crear t칰neles. SSH es un protocolo que no s칩lo cifra y garantiza la integridad de los datos, sino que es capaz de encapsular cuantas conexiones necesitemos en una sola. As칤, nuestro prop칩sito es que SSH cree un servidor local en nuestra m치quina, por ejemplo con el puerto 8081, recoga todo lo que escribamos en 칠l, lo env칤e cifrado hasta la m치quina 192.168.1.1 (la m치quina remota a la que nos hemos conectado v칤a SSH) y desde all칤 los descifre y los env칤e al puerto 8080 de la m치quina 192.168.1.100; los paquetes de respuesta seguir치n el proceso inverso, hasta llegar al puerto 8081 local de nuestra m치quina. Observes칠 que en el caso del t칰nel los paquetes pasan por la capa de aplicaci칩n, mientras que en el NAT simplemente se modifican las cabeceras a nivel IP y TCP para hacer el NAT. La m치quina 192.168.1.100 no ver치 como IP origen de los paquetes a la IP de nuestra casa, sino a 192.168.1.1, la m치quina SSH que ha retransmitido el paquete.</P
><P
>En la pr치ctica, hacer el t칰nel es tan sencillo como:
<KBD
CLASS="userinput"
>ssh -N 801020.13 -p 34231 -o ServerAliveInterval 1200 -L8081:192.168.1.100:8080</KBD
></P
><P
>La opci칩n -N es para crear el t칰nel pero no iniciar una shell. La opci칩n ServerAliveInterval es para enviar cada 2 minutos un paquete en caso de que la conexi칩n est칠 inactiva, para evitar que el cortafuegos asuma que la conexi칩n est칠 muerta y olvide la asociaci칩n NAT. Es posible a침adir m치s opciones interesantes. Por ejemplo por defecto el puerto 8081 que ha creado ssh es s칩lo accesible dentro de nuestra m치quina, si quisi칠ramos que pudieran conectarse a 칠l otras m치quinas de nuestra red local, a침adiremos la opci칩n -g.</P
><P
>Es posible tambi칠n crear t칰neles en los que el puerto servidor se abre en la IP a la que nos conectamos remotamente (en este caso 192.168.1.1) y que se enviara a una IP y puerto de nuestra red local. Esto nos permite crear servidores en la red local de nuestra empresa (para que el puerto sea accesible desde todas las Ips de la red local de la empresa y no s칩lo desde 192.168.1.1, habr치 que usar la opci칩n -g).</P
><P
>As칤, si queremos crear el puerto 8087 en 192.168.1.1 y que todo lo que se reciba all칤 vaya al puerto 9000 de la IP 192.168.7.3 (en nuestra red local de casa) usar칤amos:
<KBD
CLASS="userinput"
>ssh -N 801020.13 -p 34231 -o ServerAliveInterval 1200 -g -R192.168.1.1:8087:192.168.7.3:9000</KBD
></P
><P
>Como puede verse, los t칰neles SSH son muy potentes y un tanto inquietantes desde el punto de vista de la seguridad para un administrador: podemos hacer un t칰nel para usar el escritorio remoto, para conectarnos a la web de la empresa, para enviar correos desde casa utilizando el servidor SMTP de la empresa, e incluso para ejecutar una aplicaci칩n en local que usa una BB.DD. de la red, cambiando la configuraci칩n para que use un puerto en nuestra m치quina local y usando un t칰nel. Es m치s, es posible crear toda una VPN como veremos m치s adelante, con s칩lo la posibilidad de crear t칰neles de SSH.</P
><P
>Por este motivo el administrador de SSH puede desactivar el uso de t칰neles o especificar exactamente qu칠 t칰neles se pueden usar, as칤 como permitir o denegar obtener una shell o permitir ejecutar s칩lo un comando en concreto. Puede as칤 mismo no permitir el acceso al sistema no d치ndole una contrase침a y autenticando por clave p칰blica: el propio fichero de clave p칰blica almacenado en el servidor tendr치 las restricciones que se aplican cuando se accede con esa clave, pudi칠ndose tener distintas claves para un mismo usuario seg칰n se le permita ejecutar una tarea u otra. El administrador tambi칠n puede limitar lo que hagan los usuarios en el fichero de configuraci칩n global sshd_config mediantve la directiva Match, por usuario, grupo, direcci칩n o host de origen.</P
><P
>La funcionalidad de SSH no acaba aqu칤. Es posible que un usuario se conecte a una m치quina y desde ah칤 a otras. Si utiliza claves p칰blicas para autenticarse, SSH incorpora un sistema, el ssh-agent, que permite autenticar al usuario estando conectado en otra m치quina y sin que nuestra clave privada salga de nuestra m치quina. Esta funcionalidad tambi칠n es necesaria si se usa una tarjeta criptogr치fica, pues la clave privada no puede extraerse de la tarjeta ni siquiera por su propietario.</P
><P
>Para usuarios con Windows, en lugar de utilizar el cliente en l칤nea de comandos pueden recurrir a Putty, un programa con interfaz de usuario basada en ventanas y que en realidad tambi칠n se puede ejecutar en GNU/Linux.</P
><P
>Un peque침o detalle con SSH: el lanzar programas para ejecutar en modo batch (segundo plano) y que ssh retorne inmediatamente, sin esperar a que el programa lanzado termine. Si se abre una sesi칩n y se lanzan con nohup funciona, pero si se invoca directamente con ssh un programa no; el cliente de ssh se queda esperando hasta que el programa acabe. El motivo por el que espera es porque la entrada/salida est치 redirigida a sockets y hasta que ssh no detecta que esos sockets est치n cerrados, no retorna. En la shell interactiva esto no pasa, porque al ejecutar nohup, aparte de no considerarse la se침al HUP al morir la shell, que es algo que a SSH ni le va ni le importa (y que se puede hacer en cualquier momento aunque el programa no se lanzara con nohup, mediante el comando interno de la shell disown), ocurre que salida est치ndar y de error se redirige al fichero nohup.out y la entrada est치ndar a /dev/null, cerr치ndose la que hasta ahora era E/S est치ndar y de error, por lo que ssh ya no tiene que esperar. 쯇ero por qu칠 la diferencia de comportamiento? La diferencia est치 en que en con una sesi칩n interactiva se usa un ptty (un terminal virtual) mientras que con un comando aislado no, se usan los sockets directamente y nohup s칩lo hace la redirecci칩n si la E/S est치 asociada a un terminal, pues esa es su funci칩n, que el programa no utilice un terminal que ya no est치 disponible, mientras que sin son ficheros se supone que aunque muera la shell los ficheros siguen existiendo.</P
><P
>La soluci칩n por lo tanto est치 o bien en manualmente redigir la E/S est치ndar y de error a nohup.out o /dev/null, o invocar con la opci칩n -t para que se cree un TTY virtual.</P
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notas</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN363"
HREF="c347.html#AEN363"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Openssh no es la 칰nica implementaci칩n libre de SSH. A destacar dropbear (<A
HREF="http://matt.ucc.asn.au/dropbear/"
TARGET="_top"
>http://matt.ucc.asn.au/dropbear/</A
>), usado sobre todo en sistemas empotrados como PDAs, tel칠fonos, routers por ser mucho m치s ligero que openssh... La mayor칤a de lo expuesto en este manual sobre openssh funciona igualmente en dropbear.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x314.html"
ACCESSKEY="P"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c380.html"
ACCESSKEY="N"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Servidor Jabber</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Redes Privadas Virtuales (VPN)</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>