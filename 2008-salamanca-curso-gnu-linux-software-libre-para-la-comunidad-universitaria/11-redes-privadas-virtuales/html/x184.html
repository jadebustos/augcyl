<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Capa de aplicaci√≥n (Layer5; Layer7 en OSI)</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="GNU/Linux, software libre para la comunidad universitaria"
HREF="index.html"><LINK
REL="UP"
TITLE="Paquetes de red. Modelo en Capas"
HREF="c34.html"><LINK
REL="PREVIOUS"
TITLE="Capa de transporte (Layer4)"
HREF="x155.html"><LINK
REL="NEXT"
TITLE="Autoconfiguraci√≥n: DHCP, PXE, Zeroconf"
HREF="c209.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GNU/Linux, software libre para la comunidad universitaria: Redes privadas virtuales en GNU/Linux</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x155.html"
ACCESSKEY="P"
>Anterior</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>CapÌtulo 2. Paquetes de red. Modelo en Capas</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c209.html"
ACCESSKEY="N"
>Siguiente</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN184"
>2.4. Capa de aplicaci√≥n (Layer5; Layer7 en OSI)</A
></H1
><P
>Finalmente la √∫ltima capa es el protocolo de aplicaci√≥n, por ejemplo HTTP (web), SMTP (correo) o XMPP (Jabber). En Unix estos protocolos se escriben utilizando sockets, que se utilizan (sobre todo cuando la capa de transporte es TCP) pr√°cticamente igual que los ficheros. Existe una especificaci√≥n de un framework llamado BEEP (RFC 3080-3081, 3620), con implementaciones libres, que permite crear protocolos de aplicaci√≥n olvidando temas como la autenticaci√≥n y negociaci√≥n de un canal seguro (para lo que usa SASL y TLS respectivamente) as√≠ como el modo de multiplexar varios canales sobre una conexi√≥n o manejar mensajes as√≠ncronos (en cambio el formato de los mensajes en s√≠ es libre). Tambi√©n estandariza la creaci√≥n de t√∫neles (proxies).</P
><P
>Dado que con los sniffers es posible espiar el tr√°fico de red, un mecanismo de seguridad muy utilizado en las aplicaciones es a√±adir una capa intermedia en la capa de aplicaci√≥n sobre la que realmente va el protocolo: esta subcapa lo que hace es cifrar los paquetes y a√±adirles informaci√≥n de control para detectar si alguien los intenta manipular. El protocolo m√°s est√°ndar par implementar esta funcionalidad es TLS (anteriormente conocido como SSL). </P
><P
>Ojo, puede parecer que un switchs elimina la posibilidad de que un nodo en una red local esp√≠e las comunicaciones entre otros nodos, utilizando un sniffer. Al fin y al cabo con un hub todo el tr√°fico se reenviaba a todos los nodos y el nodo en escucha realiza una actividad totalmente pasiva e indetectable, pero con un swtich se supone que cada nodo s√≥lo recibe los paquetes que van destinados a √©l. Lamentablemente no es as√≠, existen sniffers como <A
HREF="http://ettercap.sourceforge.net/"
TARGET="_top"
>http://ettercap.sourceforge.net/</A
> que funcionan tambi√©n con switchs<A
NAME="AEN190"
HREF="#FTN.AEN190"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>. As√≠ mismo hay sniffers especializados como oreka.sf.net, que sirven para grabar VoIP, generando un fichero de audio.</P
><P
>El problema es el ARP Spoofing/Port Stealing y ARP Poisoning. El ARP poisoning consiste en enviar al nodo que queremos enga√±ar una respuesta ARP en el que indicamos que nuestra direcci√≥n MAC es la correspondiente a la direcci√≥n IP del nodo que queremos suplantar. La mayor√≠a de los sistemas operativos no ven nada extra√±o en que les llegue este paquete aunque no lo hayan solicitado y lo almacenan en su cach√© ARP y en los que no se puede trucar con un ping. El ARP posioning act√∫a falsificando la IP no la direcci√≥n ARP, por lo que es dif√≠cil de detectar y evitar por parte del switch. Otras t√©cnicas (Port Stealing) explotan enga√±ar al switch haci√©ndole creer que tenemos la direcci√≥n ARP de la m√°quina a suplantar (los swtich que no soporten Safe Port, es decir, que permitan que cambie el puerto asociado a una direcci√≥n MAC). As√≠ mismo hay ataques que buscan saturar con entradas falsas la tabla CAM del switch, pues necesariamente esta tabla tiene capacidad limitada.</P
><P
>La buena noticia es que estos ataques ya no son pasivos sino activos y son detectables con herramientas apropiadas como arpwatch (que hace escucha pasiva) o el propio ettercap. M√°s informaci√≥n: <A
HREF="http://en.wikipedia.org/wiki/ARP_spoofing"
TARGET="_top"
>http://en.wikipedia.org/wiki/ARP_spoofing</A
>
</P
><P
>Si necesitamos un sniffer para hacer comprobaciones de red o aprender sobre protocolos, el sniffer recomendado es Ethereal, que ha cambiado de nombre recientemente a whireshark.</P
><P
>Hay m√°s herramientas √∫tiles para depurar problemas en las redes, adem√°s de los sniffers. Por ejemplo iftop (http://www.ex-parrot.com/pdw/iftop/ ): muestra consumo de ancho de banda, al estilo de top, mostrando origen y destino de la conexi√≥n. Utiliza libpcap (como sniffer) por lo que al ponerlo en la m√°quina que hace de router podemos ver qui√©n est√° consumiendo en ese momento m√°s ancho de banda. </P
><P
>Una herramienta extremadamente √∫til para depurar problemas de red y aprender sobre redes es Netcat. Esta utilidad permite conectarse a cualquier socket TCP/UDP y enviar/recibir datos como si estuvi√©ramos escribiendo en un terminal. De igual modo puede escuchar en un puerto TCP/UDP. Es muy √∫til por ejemplo para probar antes de montar una VPN si hay visibilidad entre las Ips y puertos: escuchamos con netcat en un lado y desde el otro enviamos. As√≠, para escuchar tr√°fico UDP en el puerto 9037 (opcionalmente con -s se podr√≠a indicar una IP, en el caso de ser un puesto multihome, con m√°s de una interfaz de red): <KBD
CLASS="userinput"
>netcat -u -l -p 9037</KBD
>. Para enviar tr√°fico a el puerto 9037 desde otra m√°quina: <KBD
CLASS="userinput"
>netcat -u 83.59.36.220 9037</KBD
></P
><P
>Otra herramienta a√∫n m√°s vers√°til que netcat, pero mucho menos conocida, es socat (<A
HREF="http://www.dest-unreach.org/socat/doc/socat.html"
TARGET="_top"
>www.dest-unreach.org/socat/doc/socat.html</A
>). Permite usar todo tipo de conexiones, incluso sockets RAW, sockets Unix, ficheros, crear dispositivos TUN/TAP, usar SSL, abrir un PTY, usar un socket HTTP o SOCKS...</P
><P
>Se recomienda usar tambi√©n un NIDS (sistema detector de intrusiones de red, tambi√©n suele usarse el acr√≥nimo IDS, pues la mayor√≠a de los IDS son NIDS, pero los hay espec√≠ficos para una aplicaci√≥n o para un sistema, que analizan llamadas al sistema). El m√°s conocido es snort (<A
HREF="http://www.snort.org/"
TARGET="_top"
>http://www.snort.org/</A
>), aunque es programa es pol√©mico debido a que las nuevas reglas para detectar intrusiones ya no son libres, aunque s√≠ gratuitas pero distribuidas con varios d√≠as de retraso para los clientes no de pago: un sitio d√≥nde hay reglas que s√≠ son libres es www.bleedingthreats.net/ . Snort es un NIDS reactivo; permite tomar medidas para neutralizar el peligro, frente a los NIDS pasivos que s√≥lo lo detectan. Los sistemas de este tipo se conocen como IPS (Intrusion Prevention System; sistemas de prevenci√≥n de intrusiones).</P
><P
>Tambi√©n es √∫til disponer de un sistema de detecci√≥n de vulnerabilidades como Nessus (lamentablemente desde la versi√≥n 3 no es software libre, pero hay un fork que s√≠ lo es <A
HREF="http://www.openvas.org/"
TARGET="_top"
>http://www.openvas.org/</A
>: el problema de todos modos es tener una base de datos de vulnerabilidades que sea de libre uso); ojo con utilizar esta herramienta en una red que no administremos, entre los cometidos de un NIDS como snort es detectar este tipo de monitorizaciones. No confundir un detector de vulnerabilidades o security scanner con un escaneador de puertos (port scanner), como nmap, aunque el escaneo de puertos forme parte del proceso de b√∫squeda de vulnerabilidades. Nmap no detecta vulnerabilidades, sino localiza qu√© m√°quinas hay en la red, qu√© puertos tienen abiertos, qu√© sistemas operativos usan y qu√© versiones de los servidores de red utilizan. Un NIDS tambi√©n detectar√° escaneos con Nmap, por lo que s√≥lo deber√≠an usar esta herramienta administradores de redes que tratan de encontrar vulnerabilidades en su propia red, principalmente debidas a m√°quinas "incontroladas" que no siguen la pol√≠tica de seguridad fijada para la red.</P
><P
>Para redes wireless hay programas como kissmet (<A
HREF="http://kismetwireless.net/"
TARGET="_top"
>http://kismetwireless.net/</A
>) que act√∫a de forma pasiva y no es detectable, permitiendo detectar de hecho ataques de programas no pasivos como netstumbler, adem√°s de poder usarse con snort y con otros sniffers (para lo cual deberemos conocer la clave). Un programa de "wardriving" (localizaci√≥n de redes Wifi desplaz√°ndose con un veh√≠culo y un port√°til con la tarjeta en modo monitor) es swscanner (<A
HREF="http://www.swscanner.org/"
TARGET="_top"
>http://www.swscanner.org/</A
>); un uso l√≠cito de este tipo de programas es detectar redes no autorizadas o que no siguen la pol√≠tica de seguridad de la empresa u organizaci√≥n, otro es comprobar temas de cobertura y un tercero depurar problemas de conexi√≥n.</P
></DIV
><H3
CLASS="FOOTNOTES"
>Notas</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN190"
HREF="x184.html#AEN190"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Otro sniffer, o conjunto de sniffer revelador de que los switch no son suficientes para evitar que se esp√≠e el tr√°fico de red es dsniff (www.monkey.org/~dugsong/dsniff/). Este paquete por un lado incluye sniffers pasivos, algunos especializados para tareas como capturas contrase√±as, correos, URLs (hay otro programa al margen de dsniff especializado para grabar VoIP en ficheros de audio, oreka.sf.net) y por otro programas para atacar los switchs. As√≠ mismo incluye programas para hacer ataques "man in middle" para servidores SSL y SSH cuando se usan certificados autofirmados o sin comprobar, presentando uno falso sobre la marcha. </P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x155.html"
ACCESSKEY="P"
>Anterior</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Inicio</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c209.html"
ACCESSKEY="N"
>Siguiente</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Capa de transporte (Layer4)</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c34.html"
ACCESSKEY="U"
>Subir</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Autoconfiguraci√≥n: DHCP, PXE, Zeroconf</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>