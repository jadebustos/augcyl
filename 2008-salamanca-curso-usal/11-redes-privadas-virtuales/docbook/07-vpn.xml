<?xml version='1.0' encoding='utf-8'?>
<chapter><title>Redes Privadas Virtuales (VPN)</title>
<sect1><title>Soluciones VPN para GNU/Linux</title>

<para>VPN es el acrónimo en inglés de red privada virtual. El objetivo es lograr, mediante la creación de un túnel IP cifrado sobre una red pública como Internet, que los nodos a conectar por la VPN virtualmente estén en una misma red local. Es posible establecer una VPN directamente entre dos nodos, pero lo más habitual es o bien una VPN entre un nodo remoto y la red local de la empresa (esta configuración en inglés se llama con frecuencia road warrior, guerrero de la carretera, hace mención a que un usuario móvil se conecta a la empresa con su portátil y una conexión a Internet desde allí dónde está desplazado) o una VPN que une dos redes, por ejemplo dos filiales de una empresa o una filial con la central.</para>

<para>Hay distintas tecnologías y productos para crear una VPN con implementaciones libres para GNU/LInux: </para>
<orderedlist>
<listitem>
<para>IPsec: el estándar por excelencia, será obligatorio en IPv6 y está implementado en muchas pilas TCP/IP también para la actual generación IPv4, incluyendo el kernel Linux. Se implementa directamente sobre la capa 3 (IP) mientras que el resto de soluciones suelen implementarse a nivel de capa de aplicación (aunque conceptualmente PPTP y L2TP son protocolos de capa de datos, se implementan como túneles, en el caso de L2TP sí es sobre UDP, en el caso de PPTP se usa GRE, que es un protocolo sobre IP). A diferencia de otras soluciones permite tanto túneles (modo túnel, entre dos security gateways, SG) como directamente cifrar la capa de transporte (modo transporte), lo que es útil cuando sólo se quiere seguridad entre dos máquinas o ya se implementa el túnel sobre una capa posterior (típicamente la de aplicación, utilizando paquetes UDP).</para>
</listitem>
<listitem>
<para>PPTP: protocolo impulsado por Microsoft. Su implementación original tenía varios fallos graves y además existe el problema de que no está tan probado como IPsec siendo también relativamente compleja. No es un estándar, aunque se publicó un RFC informativo describiendo el protocolo. El nombre completo es Point to Point Tunneling Protocol. Hay clientes de PPTP en Windows desde Windows 95, aunque Microsoft trata ahora de substituir PPTP por LLTP e IPsec, si bien PPTP ha tenido cierto éxito por su sencillez de configurar: no se usan claves públicas, sino las propias cuentas de Windows para autenticar el acceso. </para>

<para>Hay implementaciones para GNU/Linux interoperables con la implementación de Microsoft tanto del cliente (<ulink url="http://pptpclient.sourceforge.net/">http://pptpclient.sourceforge.net/</ulink>) como del servidor (<ulink url="http://pptpclient.sourceforge.net/">http://pptpclient.sourceforge.net/</ulink>) . A destacar que los desarrolladores de estas implementaciones recomiendan no usar PPTP más que si no queda otro remedio: en su lugar recomienda OpenVPN o IPsec.</para>
<para>En Ubuntu 7.10, el cliente PPTP forma parte de los paquetes oficiales. Hay además un applet para network-manager, aunque este ya no es oficial.</para>
</listitem>
<listitem>
<para>L2TP: Layer 2 Tunnel Protocol: promovido por Microsoft y CISCO, sigue la vía de estandarización del IETF (es el RFC2661). Es un protocolo que hace túneles a nivel de la capa de aplicación (mediante paquetes UDP, aunque en principio puede encapsularse sobre otro tipos de redes no IP) para transportar trápico layer2. Mediante L2TP se crea un túnel entre el LAC (L2TP Access Concetrator, el cliente) y el LNS (L2TP Network Server): una vez creado el túnel, cualquiera de las dos partes puede abrir sesiones y estas sesiones se multiplexarán sobre el túnel; un uso típico es crear una sesión PPP. L2TP garantiza fiabilidad en los paquetes de control, mientras que en los de datos como es propio de UDP podrán perderse. </para>
<para>En realidad L2TP no implementa por sí sólo una VPN, dado que no cifra la información, por lo que o bien usa PPTP o lo recomendado, usa un túnel IPsec (es decir, se usa un túnel IPsec para a su vez encapsular el túnel L2TP: esto también se estandariza por el IETF, en el RFC ).</para>

<para>¿Qué sentido tiene usar L2TP sobre IPsec, pudiendo usar directamente IPsec? una razón es usar la autenticación PPP (por ejemplo un servidor Radius) y la parte de autoconfiguración (por ejemplo proporcionar la información DNS); no obstante con IPsec también es posible autenticación y asignar IP y DNS sin necesidad de L2TP. Así mismo L2TP crea túneles a nivel 2, por lo que puede ir todo tipo de tráfico, no necesariamente IP, por ejemplo puede ir tráfico IPX o incluso se puede transportar directamente paquetes de nivel 2 como ATM. Así mismo L2TP en gran medida es más interesante para proveedores de Internet que tengan que encapsular información (por ejemplo puede multiplexar varias sesiones L2TP sobre un túnel L2TP/IPsec), que para VPNs entre oficinas (por ejemplo para revender acceso a Internet), pero en cualquier caso se agradece que haya implementaciones para GNU/Linux pues habrá servidores que no permitan conectarse directamente usando IPsec (quizás por desear usar la autenticación PPP) y requieran L2TP. En concreto usan L2TP además de Microsoft, CISCO y MacOSX . En el artículo de la Wikipedia hay enlaces a las implementaciones existentes así como a un tutorial: <ulink url="http://en.wikipedia.org/wiki/L2TP">http://en.wikipedia.org/wiki/L2TP</ulink>
</para>
</listitem>
<listitem>
<para>OpenVPN: es la solución recomendada, por su sencillez: hace un túnel TLS sobre el que se encapsulan paquetes layer 3 (IP) o layer 2 (Ethernet), pero usando UDP en lugar de TCP, aunque también se puede usar sobre TCP e incluso pasar a través de proxies HTTP. En realidad TLS no se puede implementar directamente sobre UDP, porque requiere un protocolo fiable como TCP y con UDP se tiene que permitir la pérdida de paquetes. Por ello en realidad TLS se usa para la funcionalidad de control, como negociar la sesión TLS o renegociarla en un momento dado (implementando sobre UDP un sistema para pedir de nuevo los paquetes que se puedan perder y son importantes por ser de control), sustituyendo a los protocolos PKI de IPsec. Pero además se han imitado los mecanismos presentes en las cabeceras <footnote>
<para>IPsec define dos protocolos para dar seguridad a los paquetes, AH y ESP. AH garantiza la integridad y previene replay attacks, mientras que ESP además de eso cifra. AH garantiza la integridad también de las cabeceras (por lo que no puede usarse con NAT), pero en general no es muy útil para una VPN frente a ESP, pues normalmente IPsec se usa en modo túnel, no en modo transporte, y en este caso las Ips origen y destino van dentro del paquete. No obstante sí podría ser útil para que los routers estén seguros que el tráfico proviene de determinado router, suponiendo que se use un certificado que reconozcan y que efectivamente los "secure gateway", es decir, los extremos del túnel, coincidan con los enrutadores. En modo transporte sin AH la IP de origen se puede falsificar. En modo túnel se podría falsificar la dirección del router origen o destino entre los que se establece la VPN, pero no las IP origen y destino de los paquetes, que es lo que importa a los usuarios finales. Si se desea, se puede encapsular ESP en un paquete AH, pero rara vez se hace. Bruce Schneier recomienda simplificar IPsec y eliminar el modo de transporte y AH. dejando sólo ESP y modo túnel.</para>
</footnote> de IPsec para dar seguridad a nivel de paquete y con independencia de si se pierde el paquete anterior: para ello hay que añadir una secuencia a los paquetes, así como un HMAC y contemplar varios mecanismos. Una idea similar es la que se sigue en la implementación del estándar DTLS (Datagram TLS: <ulink url="http://es.wikipedia.org/wiki/Datagram_Transport_Layer_Security">http://es.wikipedia.org/wiki/Datagram_Transport_Layer_Security</ulink>) que se define en el RFC4347 y cuya única implementación actual conocida es la que hace el proyecto OpenSSL. En <ulink url="http://unix.freshmeat.net/projects/dtls_example/">http://unix.freshmeat.net/projects/dtls_example/</ulink> hay código de ejemplo. Es posible que en un futuro se modifique OpenVPN para usar DTLS en lugar de su propio protocolo.</para>
</listitem>
<listitem>
<para>Montar una VPN sobre la marcha con OpenSSH y pppd o OpenSSH con TUN. Es una solución de compromiso ante una necesidad puntual. Si hemos instalado SSH y dejamos que pase el cortafuegos por si necesitamos conectarnos o lo usamos para cifrar un tunel con la conexión el acceso a escritorio remoto, en un momento dado podemos instalar una VPN. La idea es utilizar el software de PPP (pppd) para crear los dispositivos de red en cada extremo y comunicarlos por un túnel SSH: el software PPP escribe por salida estándar lo que lee del dispositivo de red e igualmente lo que lee por salida estándar lo pone en el dispositivo de red. Con SSH se pueden comunicar las entradas salidas de dos programas, formando un túnel. Si lo preferimos, podemos hacer el túnel utilizando Stunnel en lugar de OpenSSH. Otra opción es utilizar la opción de hacer un túnel con TUN de SSH. Una ventaja es que es algo más sencillo, se puede lanzar sin privilegios y existe TUN incluso para Windows, aunque no por ejemplo para Mac OS X. Otra ventaja es que se puede usar TAP en lugar de TUN y usarlo para hacer un bridge: pppd necesita parchearse para funcionar en un bridge (soporte BCP), pues no transmite tramas Ethernet, sino por defecto tramas IP (aunque en Linux puede transmitir IPX en lugar de IP). Otra utilidad que puede hacer el papel de openssh +TUN pero más ligera es socat (la mencionamos al hablar de netcat). Socat es una utilidad realmente versátil que también puede reemplazar a stunnel.</para>
</listitem>
<listitem>
<para>Usar un cliente sobre la VPN proporcionada por un encaminador CISCO. El cliente, al igual que OpenVPN, no necesita de ningún soporte en el kérnel. salvo TUN/TAP. Web: <ulink url="http://www.unix-ag.uni-kl.de/~massar/vpnc/">www.unix-ag.uni-kl.de/~massar/vpnc/</ulink>
</para>
</listitem>
<listitem>
<para>En grandes empresas, usar la infraestructura de VPN que ofrezca el operador para unir dos sedes (no es por tanto solución general para teletrabajo, especialmente si no tiene por qué coincidir el operador), de modo que se tiene una red privada virtual como si se tuviera una línea dedicada o una conexión dedicada a través de una red de conmutación de circuitos como las líneas telefónicas analógicas. Típicamente esto es posible si el operador utiliza MPLS, u otras tecnologías más antiguas como ATM o Frame Relay. Obviamente, requiere que el operador comercialice la posibilidad de conectar dos sedes entre sí en lugar de sólo dar servicio a Internet.</para>
</listitem>
</orderedlist>

<para>El paquete NetworkManager (<ulink url="http://www.gnome.org/projects/NetworkManager/">www.gnome.org/projects/NetworkManager/</ulink>) dispone de plugins para OpenVPN, PPTP y VPNC (para este último programa soporta los ficheros .pcf, que sería lo único que tendría que distribuir el administrador). En el caso de la versión incluida en Ubuntu 7.10, sólo aparece la opción de configurar VPN si la tarjeta está en modo "itinerante", lo que excluye la configuración manual.</para>
</sect1>
<sect1><title>IPsec</title>

<para>Hay implementaciones de IPsec para cualquier sistema Unix, MacOS X, Windows XP/2000... Una implementación de IPsec consta de dos partes: la implementación sobre la pila de protocolos TCP/IP, en el kérnel y el demonio y herramientas que se ejecutan en el espacio de usuario para establecer las claves<footnote>
<para>En realidad en IPsec de lo que se habla es de Security Associations (SA) que incluyen los parámetros de seguridad como claves, certificados, algoritmos, duración de claves, datos para evitar replay attacs, etc.. En una comunicación hay una SA por sentido. En los paquetes se incluye un número, el SPI (Secure parameter index) que junto con la IP destino y el protocolo (AH o ESP) sirve para que la otra parte encuentre la SA en una tabla, la SADB. En cada nodo hay una SPD (Security Policy Database) que básicamente es una tabla que dados unos selectores (Ips/puertos origen/destino, por ejemplo) aplica una acción, que puede ser dejar pasar el paquete tal cual o usar AH/ESP, modo transporte o modo túnel y la SA a aplicar. La implementación de Linux almacena en el kernel estas dos tablas.</para>
</footnote> (esto es la parte IKE: Internet Key Exchange<footnote>
<para>En la versión anterior de los RFC de IPsec, en realidad se hablaba de ISAKMP, para la gestión de las SA, que para la parte del intercambio de claves podía usar distintos protocolos, aunque en la práctica se establecía IKE. En la versión actual, IKE2, engloba todo.</para>
</footnote>). En principio es posible utilizar la parte IKE de una implementación sobre la pila de protocolos de otra. Así, la implementación integrada en el kernel Linux (llamada NETKEY) no incluye herramientas IKE, por lo que hay que usar las de otra implementación: habitualmente se usa la implementación del proyecto Kame (surgido de un consorcio de empresas japonesas como Fujitsu y Toshiba para hacer una implementacion de Ipv6 e IPsec), que es la implementación usada en Free/NetBSD y en MacOS X; el demonio IKE de Kame se llama Racoon y el conjunto de utilidades portadas para Linux que además de Racoon incluye otras como setkey es IPsec-tools (http://IPsec-tools.sf.net); en Ubuntu Dapper existen por separado los paquetes IPsec-tools y Racoon (sólo necesitamos el demonio si la asociación de seguridad se negocia vía IKE (puerto UDP 500), no lo necesitamos si se hace manualmente con setkey; setkey puede ser necesario para establecer la política (al estilo de como se crea una regla de filtrado con iptables, setkey sirve tanto crear políticas indicando que se use redcoon para negociar la SA, como para crear directamente la SA), pero también se puede hacer a nivel de conexión con setsockopt y libipsec, incluida en el paquete racoon. </para>

<para>También se puede usar por ejemplo como demonio IKE isakmpd (de la implementación de OpenBSD) o Pluto. Pluto es el demonio IKE de la antigua implementación de IPsec para Linux, FreeSWAN, que nunca llegó a formar parte del kernel; FreeSWAN dejó de desarrollarse pero tomaron el relevo dos proyectos: OpenSWAN (<ulink url="http://www.openswan.org">www.openswan.org</ulink>) y StrongSWAN (<ulink url="http://www.strongswan.org">www.strongswan.org</ulink>). Mientras que OpenSWAN sigue desarrollando la pila de protocolos KLIPS como alternativa a la integrada en el kernel, NETKEY(pero su parte IKE funciona tanto con KLIPS como con NETKEY), en StrongSWAN ya sólo soportan NETKEY. StrongSWAN es compatible no sólo con IKE1 sino con IKE2<footnote>
<para>StrongSWAN no es la única implementación libre de IKE2. Existe también racoon2, ikv2 y el proyecto español openikev2 (http://openikev2.sourceforge.net/)</para>
</footnote>: de la compatibilidad con IKE1 se encarga el viejo demonio Pluto, mientras que para IKE2 hay un nuevo demonio llamado Charon. La flexibilidad de programas como StrongSWAN o OpenSWAN son inmensas: incluyendo toda una infraestructura de clave pública basada en certificados X.509, con la posibilidad de utilizar dispositivos como smartcards y teniendo en cuenta aspectos como que los certificados pueden revocarse y ya no ser válidos, que pueden obtenerse de servidores LDAP... Otra característica interesante es "oportunistic encryption", que se basa en situar los certificados en servidores DNS. Ahora bien, para que esto sea seguro, hay que usar DNSSEC, pero esta especificación está poco implementada y hay problemas de seguridad y privacidad por permitir obtener todas las entradas DNS de un servidor<footnote>
<para>Hay más detalles de esto en la wikipedia. La idea básica es que los errores de no encontrado también hay que firmarlos, pero como la clave privada no tiene por qué estar online, estos mensajes pueden estar prefirmados; para que estos mensajes sean finitos, se indica que entre tal nombre y tal otro no existe esa entrada.</para>
</footnote>.</para>

<para>Para usar IPsec hay que abrir en los cortafuegos el puerto 200 UDP, pues lo usa IKE. También hay que tener en cuenta que los paquetes tienen un número de protocolo distinto al IP, por lo que también podría haber problemas en el cortafuegos.</para>

<para>El lado negativo de IPsec es que es una solución muy compleja<footnote>
<para>Hay 9 documentos para describir IPsec (RFC 4301-4309, de Diciembre de 2005, todavía es frecuente encontrar referencias a la versión anterior de estos documentos, RFC 2401-2409 y aún hay otra más antigua, totalmente incompatible) más otros complementarios para explicar cómo traspasar los cortafuegos, así como por ejemplo para especificar IPKMOBIL (para clientes con IP móvil y para máquinas multihome) . De todos modos IKE2 simplifica IKE, a la par que evita algunos de sus problemas, en concreto denegaciones de servicio. Si oímos hablar de cosas como main vs agressive mode, se refieren a la versión vieja, IKE.</para>
</footnote>, sobre todo lo que tiene que ver con la parte IKE. Al margen que esa complejidad podrá afectar más o menos al usuario según los asistentes para configurar una VPN (el problema está en que todo se complica más si los sistemas operativos de los nodos a conectar son distintos<footnote>
<para>Los problemas de interoperabilidad se dan practicamente siempre en la parte IKE. Son muchos los parámetros negociables y no hay unos valores por defecto que todas las implementaciones tengan que proporcionar. En la mayoría de los casos si algo sale mal no se muestra claramente la causa y si se muestra no es comprensible para alguien que no conozca a fondo IPsec. Para complicar más las cosas, IKE2 no es compatible con IKE1, aunque se pueden implementar los dos usando el mismo demonio y puerto UDP. Así mismo hay extensiones, por ejemplo en IKE con X-AUTHse pueden utilizar mecanismos adicionales de autenticación; en IKE2 se usa EAP (como en WPA/WPA2-Enterprise en las redes Wifi y en general en dispositivos que usen la autenticación de IEEE802.1X).</para>
</footnote>, frente a la sencillez de usar una implementación de VPN más simple que tenga versión para distintos sistemas operativos) desde el punto de vista de la seguridad son preferibles las soluciones sencillas. Hay gente que no le gusta tampoco de IPsec frente a otras soluciones que se ejecute mucho código en el espacio del kernel (por ejemplo la parte de cifrado, que en el caso de OpenVPN se ejecuta en el espacio de usuario) dado que un error de seguridad ahí es fatal al comprometer todo el sistema, si bien tiene un impacto positivo en el rendimiento. Esta objeción es opinable: es cierto, pero también la información sensible está más protegida a nivel del kernel.</para>
<sect2><title>Caso práctico: IPsec en modo transporte, usando preshared keys</title>
<para>La IP de nuestra máquina es 10.0.0.1 y queremos que haya conexiones seguras con otra máquina de la red local, la 10.0.0.2. Vamos a crear la SA (Security Association) directamente con setkey, por lo que no necesitamos el demonio racoon, dado que no usamos IKE. Usaremos PSK (pre-shared keys). Para ello, creamos el siguiente fichero y lo grabamos como "politica.txt":
<screen>add 10.0.0.1 10.0.0.2 esp 7320 -E 3des-cbc "i92dfafgehogexxxx1112222"; 
add 10.0.0.2 10.0.0.1 esp 6698 -E 3des-cbc "xxxXXXXXXrjZZZ(xx111z&lt;&lt;3";
spdadd 10.0.0.2 10.0.0.1 any -P out ipsec esp/transport//require;
</screen>
</para>

<para>Los números 7320 y 6698 son los de la SA; nos basta con elegir un entero de hasta 32 bits al azar, sabiendo que del 0 al 255 están reservados y que estos números tienen que ser únicos por cada nodo.</para>
<para>La clave en cada sentido la hemos especificado para 3DES, que son 192bits, o lo que es lo mismo, 24 bytes; si especificamos la cadena como texto (otra opción es como número hexadecimal, comenzando por 0x y sin entrecomillar) deberá tener exactamente esa longitud.</para>
<para>Hay que ejecutar en la máquina <userinput>keyutil -f politica.txt</userinput>. Tras transferir el fichero a la máquina 10.0.0.2 haremos lo mismo, pero tras invertir las direcciones en la última línea del fichero.</para>
</sect2></sect1>
<sect1><title>SSH + PPPD / SSH + TUN</title>

<para>¿Qué inconvenientes tiene usar OpenSSH + PPPD o TUN? el principal inconveniente es que no es buena idea implementar el túnel de una VPN sobre TCP, es mejor utilizar UDP. El motivo es porque TPC tiene mecanismos de control de congestión que no funcionan de la mejor forma cuando una conexión TCP a su vez se encapsula sobre una conexión TCP: se produce un efecto multiplicativo que hace que ante una congestión se reduzca la velocidad enormemente y que tarde mucho en coger de nuevo velocidad. Hay una explicación de este fenómeno en <ulink url="http://sites.inka.de/sites/bigred/devel/tcp-tcp.html">http://sites.inka.de/sites/bigred/devel/tcp-tcp.html</ulink>. Otro argumento para usar UDP es que podemos tener aplicaciones UDP que usan este protocolo por la necesidad de que los paquetes lleguen siempre a tiempo, sin importar si se pierde alguno: como se usa TCP, los paquetes nunca se descartan y se gasta tiempo en retransmisiones.</para>

<para>Paradójicamente, hay casos en los que usar un túnel TCP sí puede tener alguna ventaja sobre un túnel UDP. Si un protocolo UDP está mal diseñado frente a un ataque que selectivamente hace que determinados paquetes se pierdan, el que vaya sobre TCP sería una ventaja puesto que entonces TCP nos garantiza que ningún paquete se pierda ni llegue fuera de orden.</para>

<para>Otro inconveniente es que PPPD requiere privilegios de superusuario, aunque se pueden hacer cambios en la configuración para que no sea necesario, atendiendo a que el programa se ejecuta con el bit setuid. Crear un dispositivo TUN/TAP también requiere privilegios, pero es distinto, porque una vez creado con un programa, se puede hacer que esté disponible para otros programas lanzados sin privilegios.</para>
<sect2><title>Caso práctico: SSH + PPPD</title>

<para>Supongamos que la IP pública dónde escucha el servidor SSH es 157.88.66.102 y el puerto es 8088 . Vamos a crear una conexión punto a punto, en el que la IP local del enlace punto a punto (esta IP será la que tendrán como origen los paquetes lleguen a la red remota a través del túnel y tengan como origen la máquina local) será 172.16.16.15 y el remoto 172.16.16.16. Realmente podemos escoger el par de Ips que queramos, con tal que la IP remota no esté en uso en la propia red, teniendo en cuenta que en el otro extremo la IP local será la remota y por lo tanto la que no tiene que estar presente; no pasa nada porque la IP local sea la IP asignada a otra interfaz de red de la máquina. Ejecutamos:
<userinput>pppd updetach nobsdcomp nodeflate usepeerdns noauth connect-delay 10000 pty "ssh root@157.88.66.102-o ServerAliveInterval=120 -p 8088 -t -t pppd noauth 172.16.16.16:172.16.16.15"</userinput></para>

<para>La opción updetach es para que el programa pase a segundo plano tras lograr ejecutar la conexión (es decir, se ejecuta como si fuera un demonio, liberando el terminal). Las opciones nobsdcomp y nodeflate son para evitar que se use compresión, que no se llevaría bien con el usar un túnel SSH. Basta ponerlas en el lado cliente, pues se negocian para los dos lados de la comunicación. La opción "usepeerdns" es para que se actualice nuestro /etc/resolv.conf con los datos del servidor DNS del extremo con el que conectamos; a fin de usar su DNS en lugar del nuestro. Sin embargo es posible que esta opción no nos funcione, pues requiere que haga su trabajo el script local /etc/ppp/if-up, que no siempre tiene en cuenta estos datos, por lo que es posible que tengamos que modificarlo manualmente. La opción noauth se usa para que no use la autenticación PPP: no hace falta, dado que ya usamos la de SSH. La opción connect-delay en este caso indica que no intente establecer la conexión PPP hasta transcurridos 10 segundos; el motivo es que el pppd en el otro extremo se ejecuta al lograr autenticarnos con el servidor SSH, para lo que tendremos que introducir la contraseña antes; es decir, nos damos 10 segundos de margen para lograr ejecutar en el otro extremo pppd vía ssh. Finalmente la opción pty es para usar como script de conexión, con el se comunicará usando un pseudo-tty, lo que va entrecomillado, que no es otra cosa que lanzar pppd en la máquina remota. Entre las opciones de SSH, a destacar ServerAliveInterval: le estamos indicando en este ejemplo que envíe un paquete cada 2 minutos si no se transmiten datos, a fin de garantizar que el posible NAT que haga algún enrutador no se pierda por considerar que la conexión ya no está activa.</para>

<para>En realidad es posible simplificar la instrucción anterior, así como mejorar la seguridad, usando para autenticarse con el servidor un certificado y configurando en el servidor que al conectarse con ese certificado en lugar de poder ejecutar cualquier programa ejecute una orden determinada, que en nuestro caso sería la invocación a pppd.</para>

<para>Tras ejecutar esta operación, tendremos un nuevo dispositivo ppp0, con IP local 172.16.16.15 e IP remota 172.16.16.16. Para llegar a las máquinas remotas caben dos opciones: una es que perdamos la conectividad local (nuestro acceso a Internet), usando como ruta por defecto 172.16.16.16; esto lo podemos hacer con <userinput>route del default &amp;&amp; route add default gw 172.16.16.16</userinput>, aunque también podíamos haber pasado directamente la opción "defaultroute" a pppd para que hubiera aplicado este cambio automáticamente. Sin embargo, al ejecutar esta operación nos encontramos con un problema: no funciona, porque hasta el servidor SSH tenemos que llegar usando nuestra antigua ruta por defecto (la de nuestro router que nos permite salir a Internet). Así pues, suponiendo que nuestro entrutador a Internet es 192.168.1.1, añadimos una ruta:
<userinput>route add host 157.88.66.102 gw 192.168.1.1</userinput></para>

<para>La otra opción es que sólo añadamos una ruta específica para llegar a las Ips de la red remota y que para la ruta por defecto sigamos usando la ruta que tenemos. Así, si la red remota es 192.168.10.0, ejecutaremos:
<userinput>route add -net 192.168.10.0 -netmask 255.255.255.0 gw 172.16.16.16</userinput></para>

<para>Esta segunda alternativa encierra más riesgo de seguridad, pues si hay agujeros en nuestra máquina y estamos conectados a Internet, estaremos arriesgando la red remota, pues los paquetes que vienen de nuestra máquina no pasan por el cortafuegos de la red remota.</para>

<para>Con la IP que hemos escogido como dirección local, los paquetes que enviemos llevarán como IP origen 172.16.16.15 (la IP local en el enlace punto a punto); posiblemente en la red destino no sepan cómo llegar a esta IP desde otro nodo que el del servidor SSH, por lo que sería una conexión host a host, salvo que precisamente la máquina del servidor SSH sea el enrutador por defecto. Aún así, si por ejemplo este router a su vez pasa al testigo a otro para llegar a Internet o determinadas redes, con esa IP no llegaremos porque no se esperan que la IP 172.16.16.15 esté en ese router.</para>

<para>Hay dos formas de solucionarlo. Una es utilizar como IP local una IP de la red destino que no se esté usando y pasar al servidor la opción proxyarp. En ese caso cuando desde un nodo de la red local se pregunte por la IP, responderá la máquina donde está el servidor SSH con su propia dirección ARP y hará una redirección. La otra solución es hacer NAT; supongamos que la IP en la red remota del nodo que es servidor SSH es 192.168.10.7; entonces habría que ejecutar en la máquina remota (para lo cual podemos usar nuestro ssh) la orden para añadir la regla NAT:
<userinput>ssh 81.33.18.197 -p 9436 iptables -t nat -A POSTROUTING --source 172.16.16.15 -j SNAT --to-source 192.168.120.19</userinput></para>

<para>Esta solución tal como está es sólo para los paquetes procedentes del equipo local: si lo que hemos hecho es usar el túnel VPN para unir a la red remota toda la red local ya es más complicado, pues la IP origen será la de la máquina de procedencia.</para></sect2>
<sect2><title>Más sencillo: servidor SOCKS de SSHD</title>
<para>En realidad, si se tiene acceso a una máquina de la red local remota vía SSH, hay un método más sencillo para que nuestras aplicaciones de red accedan a los nodos de la red remota como si nuestra máquina estuviera allí. Se trata del servidor de SOCKS5 que integra OpenSSH. Este servidor se arranca en nuestra máquina local en el puerto que le indiquemos con la opción -D. Cualquier cliente que utilice ese proxy SOCKS accederá a la red remota, pues el proxy hace las peticiones en la máquina remota: todas las peticiones y respuestas van tuneladas y cifradas en la conexión SSH. De este modo, es como si las aplicaciones pudieran crear túneles SSH a petición, pero utilizando un protocolo estándar, SOCKS.</para>

<para>Una característica interesante de SOCKS5 es que para establecer una conexión se puede pasar al proxy en lugar de la IP directamente el nombre de la máquina. Esta posibilidad es interesante, porque así usamos el DNS de la red remota, en lugar de el nuestro local, algo muy deseable si es un DNS privado.</para>

<para>Hay aplicaciones que se pueden configurar para usar SOCKS, como Firefox. No obstante Firefox por defecto no usa el DNS remoto. Para que sí lo haga, bastará con teclear about:config y cambiar la opción network.proxy.socks_remote_dns.</para>

<para>Muchas aplicaciones no soportan SOCKS. La buena noticia es que se pueden "sockificar": la idea es reemplazar en tiempo de ejecución la librería estándar de C para que ante un connect o un bind llame en su lugar al proxy SOCKS. La única pega es que esto no sirve para usar el servidor DNS remoto, aunque la alternativa es abrir un túnel con SSH al servidor remoto y usarlo en lugar del local. En algunos casos parece que también resuelve el caso del DNS, alterando la llamada para hacer la consulta para hacerla a través del servidor SOCKS. Ejemplo (sólo para TCP) <ulink url="http://proxychains.sourceforge.net/">http://proxychains.sourceforge.net/</ulink>. Más programas en http://en.wikipedia.org/wiki/SOCKS.</para>

<para>"Sockificar" una aplicación es muy sencillo en cualquier programa que no tenga bit setuid: basta con usar LD_PRELOAD. </para>
</sect2>
</sect1>
<sect1><title>SSH con TUN</title>
<para>Las versiones recientes de SSH permiten crear túneles TUN o TAP de forma muy sencilla. Para ello hay que comenzar por modificar sshd_config para autorizar que se creen túneles. Se trata de la directiva PermitTunnel y deberemos dar valor yes para autorizar ambos tipos de túneles, "point-to-point" para autorizar sólo los TUN y ethernet para autorizar sólo los TAP.</para>
<para>Sólo el usuario root puede crear túneles: tiene que ser root tanto quien ejecute el cliente ssh, como la cuenta destinataria a la que conectar. El túnel existe mientras dure la conexión.</para>
<para>El cliente puede indicar que quiere crear el túnel de tres maneras distintas:</para>
<orderedlist>
<listitem>
<para>Mediante la opción -w &lt;número_dispositivo_tun_local&gt;[:&lt;número_dispositivo_tun_remoto&gt;, por ejemplo -w 0,0 si queremos que tanto en local como en remoto se use tun0.</para>
</listitem>
<listitem>
<para>Indicando en ssh_config que queremos crear el túnel al conectarnos como root. Hay que rellenar la directiva Tunnel (mismos valores que PermitTunnel en el servidor) y TunnelDevice, con la misma sintáxis que la opción -w</para>
</listitem>
<listitem>
<para>Usar un certificado con la opción tunnel="&lt;núm_dispositivo&gt;", idealmente además fijado el comando a ejecutar a uno que configure el dispositivo TUN, dado que todas estas opciones crean los dispositivos pero no les asignan una IP ni les configuran en absoluto.</para>
</listitem>
</orderedlist></sect1>
<sect1><title>OpenVPN</title>
<para>El hecho de usar protocolos conocidos y una librería muy probada como OpenSSL da mucha fiabilidad a este programa: es relativamente fácil fallar estrepitosamente a la hora de tratar de crear un nuevo sistema de VPN, como revela este interesante escrito de Peter Gutmann (el autor de cryptolib y la impresionante presentación/tutorial de criptografía de más de 800 transparencias)</para>
<para>que habla de CIPE, VTUN y TINC: <ulink url="http://www.cs.auckland.ac.nz/~pgut001/pubs/linux_vpn.txt">http://www.cs.auckland.ac.nz/~pgut001/pubs/linux_vpn.txt</ulink>. Del mismo autor, un artículo más elaborado sobre el tema: http://www.linux-magazine.com/issue/39/VPN_Insecurity.pdf</para>


<para>OpenVPN consta de un único ejecutable (para ambos extremos es el mismo) y un fichero opcional de configuración, además de los ficheros de claves.</para>

<para>Uno de los puntos fuertes es que es multiplataforma: el poder usar exactamente el mismo programa en GNU/Linux, cualquier BSD, Solaris, Mac OS X o Windows XP/2000 supone hacer una VPN en la que intervengan equipos con cualquier sistema operativo sin problemas de interoperabilidad.</para>

<para>OpenVPN permite hacer túneles a nivel de la capa 3 (la opción por defecto y la recomendada, se usa un dispositivo TUN) o a nivel de la capa 2 (usando un dispositivo TAP). Si usamos la capa 2, podemos utilizar un puente. Sólo tiene sentido usar la capa 2 en casos especiales, principalmente si necesitamos un puente o vamos a transferir distintos tipos de tráfico (IP, IPX...) simultaneamente. Por ejemplo es útil utilizar un puente para tener una IP propia asignada por un servidor DHCP en la red remota, aunque es posible lograrlo (con más trabajo) utilizando proxyarp o usar un proxy de DHCP.</para>

<para>Una funcionalidad interesante de OpenVPN desde su versión 2.0 es crear un único servidor al que pueden conectarse distintos clientes, para crear cada uno su propia red privada virtual con la red local en la que está el servidor; en este modo además el servidor puede pasar configuración al cliente, incluyendo opciones DHCP. El modo servidor de OpenVPN requiere el uso de certificados, en cambio en el modo tradicional (peer2peer) se pueden usar certificados o claves compartidas; en este último caso no se utiliza TLS ni criptografía de clave pública.</para>

<para>OpenVPN no soporta STUN ni TURN para superar problemas en el caso de que las dos partes estén tras NAT, pero en su defecto soporta SOCKS, como proxy UDP.</para>
<para>OpenVPN se adapta muy bien al caso de sitios con IP cambiante que usan DNS dinámico. Tiene una opción para reiniciarse si la otra parte no responde a unos pings periódicos, para volver a establecer la conexión.</para>

<para>El programa incluye un gran número de opciones: limitar ancho de banda, autenticar por usuario y contraseña además de por certificado, listas de revocación de certificados... Así mismo se puede usar con una smartcard (actualmente en la versión beta sólo).</para>
<sect2><title>Caso práctico: OpenVPN</title>
<para>Supongamos que queremos conectarnos las máquinas con IP públicas 83.59.36.220 y 81.33.18.197. La primera tiene abierto en el cortafuegos el puerto UDP 9037, mientras que la segunda tiene el 1198. Vamos a crear una red privada virtual, en el que el primer nodo tendrá la IP 10.4.0.2 y el segundo el 10.4.0.1.</para>

<para>La configuración más sencilla de manejo de una clave común es utilizar una clave compartida. Para ello en primer lugar la generamos en uno de los nodos:
<userinput>openvpn --genkey --secret static.key</userinput></para>

<para>A continuación la subiremos al otro nodo utilizando algún procedimiento seguro. Por ejemplo con scp (parte de SSH). Hecho esto ya podemos crear la VPN:</para>

<para>En el nodo 81.33.18.197, ejecutamos:

<userinput>openvpn --remote 83.59.36.220 --rport 9037 --lport 1198 --dev tun1 --ifconfig 10.4.0.1 10.4.0.2 -secret static.key 0</userinput></para>

<para>En el nodo 83.59.36.220 ejecutamos:

<userinput>openvpn --remote 81.33.18.197 --rport 1198 --lport 9037 --dev tun1 --ifconfig 10.4.0.2 10.4.0.1 --secret static.key 1</userinput></para>

<para>El número que sigue a static.key simplemente tiene que ser distinto en cada lado; se utiliza para que se utilicen dos pares de claves en la sesión en lugar de un solo par.</para>

<para>En ambos nodos ejecutamos:
<userinput>echo 1 &gt; /proc/sys/net/ipv4/ip_forward &amp;
iptables -I FORWARD -i tun+ -j ACCEPT</userinput></para>

<para>La primera línea es para activar el forwarding entre interfaces de red, o lo que es lo mismo, la posibilidad de enrutado. La segunda línea es para evitar que rechace el cortafuegos el tráfico procedente de la interfaz tun. En esta línea hemos puesto I (Insert) en lugar de A (append) como viene en la documentación. Realmente es más apropiado append, puesto que así si hay reglas específicas para filtrar no nos las saltaremos, pero para probar primero que podemos establecer conexión puede ser buena idea poner la regla la primera.</para>

<para>Una vez que veamos que todo funciona, podemos invocar estos programas con la opción --daemon.</para>

<para>Si no hemos logrado conectar, posiblemente haya un problema con el cortafuegos. Podemos probar con la herramienta netcat a enviar/escuchar paquetes en estos puertos UDP.</para>

<para>Así, en 83.59.36.220 ejecutamos:
<userinput>netcat -u -l -p 9037</userinput></para>

<para>en 81.33.18.197 ejecutamos:
<userinput>netcat -u 83.59.36.220 9037</userinput></para>

<para>A continuación escribimos algo: deberá aparecer en 83.59.36.220 y lo que escribamos allí aparecer en 81.33.18.197.</para>

<para>El uso de una clave compartida no es el método más seguro. Por ejemplo si se compromete la clave se comprometen todas las conversaciones pasadas. No es un sistema de "perfect forward security". Aclaremos que hay sistemas basados en PSK (Preshared keys) que sí lo son, pero no así el de OpenVPN. La diferencia es que en algunos sistemas las PSK hacen las mismas funciones que los certificados en TLS: sirven para autentificar a la otra parte, no para obtener la clave de sesión, que se determina utilizando Diffie-Hellman. En cambio con OpenVPN sirven para establecer la clave de sesión.</para>

<para>Es posible usar proxyarp también con OpenVPN, lo que ocurre es que la forma de activarlo sí que es dependiente del sistema operativo y habrá sistemas que ni siquiera lo soporten. En el caso de Linux sería con:
<userinput>echo 1 &gt; /proc/sys/net/ipv4/conf/all/proxy_arp</userinput></para>


<para>Por supuesto también es posible activar proxy_arp a nivel de cada dispositivo de red, igual que en el caso del fordwarding. Como en el caso del forwarding, deben activarse todas las interfaces implicadas, esto es, tanto la interfaz por la que llega la pregunta como la interfaz de la que se recibe la respuesta.</para>

<para>No es necesario especificar --remote y --rport en los dos extremos, basta con hacerlo en uno (esto es útil para especificarlo sólo en el extremo que no tiene un puerto abierto en el router, se recomienda en este caso usar así mismo --nobind). El extremo en el que lo especifiquemos trata de contactar con el otro (se puede indicar varias veces con datos distintos y lo intentará secuencialmente con cada uno hasta lograrlo). Ahora bien, si lo especificamos OpenVPN dará un error si recibe un paquete de una IP o puerto distinto a alguno de los especificados. Si la IP de la otra parte puede cambiar es conveniente no usar --remote o usar --float. Un detalle cuando se usa --remote y el puerto remoto está redirigido a un puerto UDP distinto al del router, es que entonces los paquetes tendrán un puerto origen distinto al que ve la otra parte como destino, salvo que enviara antes la otra parte un paquete y el NAT del router modifique el puerto origen.</para>

<para>Otra razón para no usar --remote en uno de los dos extremos, es si por ejemplo accedemos desde nuestra casa y unas veces usamos un PC y otras otro, por lo que no podemos utilizar siempre el mismo puerto. Pero ojo, no debemos conectarnos desde dos clientes distintos a la vez, salvo que usemos el modo servidor.</para>

<para>Usar certificados en lugar de claves compartidas no es complicado en OpenVPN, gracias a la mini autoridad de certificación de prueba que incluye (en Ubuntu está en el directorio de documentación, en el subdirectorio easy-rsa). Situados en este directorio, ejecutamos: 
<userinput>source vars ; ./clean_all ; build-ca</userinput></para>

<para>Con esto ya tenemos creado el certificado y clave privada de la autoridad de certificación. Para generar el certificado y clave privada del servidor (en el supuesto que queramos modo servidor, de otro modo da igual generar todos los certificados clientes):
<userinput>./build-key-pkcs12 --server server</userinput></para>
<para>Para generar un certificado para un cliente:
<userinput>./build-key-pkcs12 cliente1</userinput></para>

<para>Generamos los parámetros DH, que deberemos pasar al lado que funciona como servidor TLS:
<userinput>./build-dh</userinput></para>
<para>En la máquina que va a funcionar como servidor TLS ejecutamos:
<userinput>openvpn --dev tun2 --remote 192.168.1.131 --ifconfig 10.5.0.2 10.5.0.1 --pkcs12 server.p12 --tls-server --dh dh1024.pem</userinput> </para>
<para>En la máquina que va a funcionar como cliente TLS ejecutamos:
<userinput>openvpn --dev tun2 --remote 192.168.1.130 --ifconfig 10.5.0.1 10.5.0.2 --pkcs12 keys/cliente1.p12 --tls-client --ns-cert-type server</userinput> </para>
<para>Para finalizar, un ejemplo de uso del modo servidor. Máquina servidor:
<userinput>openvpn --dev tun2 --server 10.5.0.0 255.255.0.0 --pkcs12 server.p12 --tls-server --dh dh1024.pem</userinput></para>
<para>Máquina cliente:
<userinput>openvpn --dev tun2 --remote 192.168.1.130 --client --pkcs12 keys/cliente1.p12 --tls-client --ns-cert-type server</userinput></para>
<para>El cliente obtendrá una IP en el rango indicado por el servidor; la IP del servidor será la x.x.x.1. Por defecto dos clientes que se conecten no podrán verse, salvo que se active una opción o el servidor añada reglas de enrutado. La opción ns-cert-type está para evitar que otro cliente con un certificado válido firmado por la CA se haga pasar por el servidor.</para>
<para>Con certificados, una opción recomendable es añadir la opción -tls-auth, con una clave compartida. Esta opción sirve para que el cliente tenga que proporcionar la clave compartida para poder continuar. Con esto se evitan ataques de denegación de servicio y posibles incidencias si un día se descubre un bug en openssl.</para>
<para>OpenVPN permite crear/usar/borrar un dispositivo TUN persistente, en lugar de crearlo al establecer la conexión y destruirlo al acabarla.</para>
</sect2></sect1></chapter>

