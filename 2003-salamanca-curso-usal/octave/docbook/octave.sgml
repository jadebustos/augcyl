
  <chapter>
    <title>Introducción a Octave</title>
    <sect1>
      <title>¿Qué es Octave?</title>
      <para>Octave es un lenguaje de alto nivel
      para realizar cálculos numéricos en el ordenador, y también es
      un programa capaz de interpretar este lenguaje y realizar los
      cálculos. Octave ofrece una interfaz de
      usuario interactiva, orientada a línea de comandos, pero también
      puede ser utilizado en modo no interactivo, leyendo sus órdenes
      de fichero.</para>

      <para>Octave originalmente fue
      desarrollado para facilitar la tarea a los estudiantes de
      Ingeniería Química de la universidad de Texas, sin que estos
      tuvieran que enfrentarse a las dificultades de la
      programación. Su flexibilidad en seguida lo hizo popular y su
      uso se expandió a otros problemas relacionados con el álgebra
      lineal y las ecuaciones diferenciales y favoreció su desarrollo,
      agregando las aportaciones de la comunidad de usuarios.</para>

      <para>Otros programas de características similares, y hasta
      cierto punto compatibles, son son el lenguaje
      R de la FSF, Matlab y Scilab. Estos
      dos últimos propietarios. Octave es
      software libre (bajo licencia GNU), lo que significa que se
      puede usar y redistribuir libremente, y que cualquiera puede
      ayudar para mejorarlo. Octave está disponible en Internet en
      <ulink url="http://www.octave.org">http://www.octave.org</ulink>.</para>
    </sect1>

    <sect1>
      <title>Usar Octave</title>
      <para>En la mayoría de los casos, la forma de arrancar Octave es
      desde la linea de comandos tecleando
      <userinput>octave</userinput>. Octave muestra un mensaje inicial
      y un prompt indicando que está esperando órdenes del
      usuario.</para>

      <screen>
	<prompt>$</prompt> <userinput>octave</userinput>
	<computeroutput>GNU Octave, version 2.0.16.92 (i386-pc-linux-gnu).</computeroutput>
	<computeroutput>Copyright (C) 1996, 1997, 1998, 1999, 2000 John W. Eaton.</computeroutput>
	<computeroutput>This is free software with ABSOLUTELY NO WARRANTY.</computeroutput>
	<computeroutput>For details, type `warranty'.</computeroutput>
	<computeroutput></computeroutput>
        <prompt>octave:1></prompt>
      </screen>

      <para>Para terminar octave, basta con teclear <userinput>quit</userinput> o
      <userinput>exit</userinput> en el prompt de Octave. </para>
      <screen>
        <prompt>octave:1></prompt> <userinput>exit</userinput>
      </screen>

      <sect2>
	<title>Ejemplos sencillos</title>
	<para>Los capítulos siguientes describen las características de octave en mayor detalle, pero antes
	de continuar es recomendable mostrar (e intentar) algunos ejemplos. Cada vez que se complete
	una linea con una pulsación de retorno de carro, Octave responderá con un segundo prompt
	para seguir recibiendo entrada del usuario, o con la respuesta (puede tardar más o menos
	según el número de operaciones necesaria para computarla) si el usuario introdujo una orden
	completa.</para>

	<para>Según se van introduciendo los comandos Octave los almacena en un "histórico de
	comandos" y permite su recuperación y edición. Simplemente pulsando las flechas del teclado
	numérico, o si esto no funcionara con las teclas <keysym>C-b</keysym> o <keysym>C-f</keysym>
	para mover el cursor a izquierdas o derechas en el comando que estamos tecleando, y con
	<keysym>C-p</keysym> y <keysym>C-n</keysym> para recuperar órdenes anteriores (retroceder en
	la historia) o volver a las últimas órdenes.
	  <tip>
	    <para>Existen otras muchas combinaciones de teclas útiles, la mayor parte de las cuales
	    coinciden con las de <application>emacs</application>.</para>
	  </tip>
	</para>

	<example>
	  <title>Definir números</title>
	  <para>El siguiente ejemplo define dos números, el primero el número real 2, y el segundo
	  el número complejo 2+2j. </para>
	  <screen>
	    <prompt>octave:1> </prompt><userinput>a=2.1</userinput>
	    <computeroutput>a = 2.1</computeroutput>
	    <prompt>octave:2> </prompt><userinput>b=a+2j</userinput>
	    <computeroutput>b = 2.1 + 2i</computeroutput>
	  </screen>

	  <para>Inicialmente, los símbolos <keysym>i</keysym> y <keysym>j</keysym> son
	  representaciones de la unidad imaginaria (<keysym>i</keysym>*<keysym>i</keysym>=-1,
	  <keysym>j</keysym>*<keysym>j</keysym>=-1). Ambos símbolos son equivalentes.
	    <caution>
	      <para>Esto es cierto siempre y cuando no se asigne otro valor a las variables
	      <keysym>i</keysym> y <keysym>j</keysym> o a sus correspondientes mayúsculas. Por eso
	      motivo se desaconseja su uso como variable. Lo mismo sucede con las constantes
	      <keysym>pi</keysym> (relación entre la longitud de la circunferencia y su diámetro) y
	      <keysym>e</keysym> (base del logaritmo neperiano)</para>
	    </caution>
	  </para>

	  <para>En la definición de la variable <keysym>b</keysym> se ha usado la variable
	  <keysym>a</keysym>. Así, si una variable está a la izquierda del signo <keysym>=</keysym>
	  se estará asignando valor a esa variable, y si está a la derecha será sustituida por su
	  valor a la hora de hacer los cálculos.</para>

	  <para>También se observa que no hay ninguna diferencia a la hora de definir un número
	  real, complejo o imaginario, o al usarlo, lo que supone una gran comodidad a la hora de
	  programar.
	    <caution>
	      <para>Octave usa el <keysym>.</keysym> (punto) para definir números decimales
	      (exactamente igual que en las calculadoras).</para>
	    </caution>
	  </para>

	  <para>Para obtener el valor de una variable basta con teclear el nombre de la variable a
	  continuación del prompt.</para>
	  <screen>
	    <prompt>octave:3> </prompt><userinput>b</userinput>
	    <computeroutput>b = 2.1 + 2i</computeroutput>
	  </screen>
	</example>

	<example>
	  <title>Crear un vector</title>
	  <para>Si queremos crear un vector fila con los elementos 1, 2, 1:</para>
	  <screen>
	    <prompt>octave:4> </prompt><userinput>v= [1 2, 1]</userinput>
	    <computeroutput>v =</computeroutput>
	    <computeroutput>  1 2 1</computeroutput>
	  </screen>

	  <para>Para crear un vector columna</para>
	  <screen>
	    <prompt>octave:5> </prompt><userinput>w= [</userinput>
	    <prompt>> </prompt><userinput>1; -1</userinput>
	    <prompt>> </prompt><userinput>2</userinput>
	    <prompt>> </prompt><userinput>]</userinput>
	    <computeroutput>w =</computeroutput>
	    <computeroutput>   1</computeroutput>
	    <computeroutput>  -1</computeroutput>
	    <computeroutput>   2</computeroutput>
	  </screen>

	  <para>Los símbolos <keysym>[</keysym> y <keysym>]</keysym> se usan para definir vectores y
	  matrices. Si se trata de un vector fila, se introducen los elementos separados por
	  espacios (o tabuladores) o por <keysym>,</keysym> (coma). Si es un vector columna se
	  introducen los elementos separados por retornos de carro o por <keysym>;</keysym> (puntos
	  y coma). En el caso de las matrices, los elementos se introducen por filas. Está permitido
	  usar cualquier cantidad de espacios para separar elementos.</para>
	</example>


	<example>
	  <title>Crear una matriz</title>
	  <para>Para almacenar la matriz identidad de rango 3 en una variable escribiríamos lo
	  siguiente:</para>
	  <screen>
	    <prompt>octave:6> </prompt><userinput>I= [</userinput>
	    <prompt>> </prompt><userinput>1 0 0</userinput>
	    <prompt>> </prompt><userinput>0 1 0; 0,0,1 ]</userinput>
	    <computeroutput>I =</computeroutput>
	    <computeroutput>  1 0 0</computeroutput>
	    <computeroutput>  0 1 0</computeroutput>
	    <computeroutput>  0 0 1</computeroutput>
	  </screen>

	  <para>Octave responde imprimiendo por pantalla la matriz correctamente formateada. A
	  partir de este momento la variable <keysym>I</keysym> contendrá la matriz identidad de
	  orden 3. El mismo resultado hubiéramos podido conseguir usando la función
	  <userinput>eye(3)</userinput>. Otros ejemplos de funciones que crean matrices son
	  <keysym>ones()</keysym>, <keysym>zeros()</keysym> y <keysym>rand()</keysym>.
	    <tip>
	      <para>Si desea saber como utilizar estas funciones teclee en el prompt de Octave
	      <keysym>help</keysym> seguido por el nombre de la función. Por ejemplo:
	      <userinput>help ones</userinput>. Por desgracia la ayuda estará en inglés.</para>
	    </tip>
	  </para>
	</example>

	<example>
	  <title>Aritmética de matrices</title>
	  <para>La notación de octave para aritmética de matrices, vectores y números es clara y
	  sencilla. Por ejemplo:</para>
	  <screen>
	    <prompt>octave:7> </prompt><userinput>b * I</userinput>
	    <computeroutput>ans =</computeroutput>
	    <computeroutput>  2.10000 + 2.00000i  0.00000 + 0.00000i  0.00000 + 0.00000i</computeroutput>
	    <computeroutput>  0.00000 + 0.00000i  2.10000 + 2.00000i  0.00000 + 0.00000i</computeroutput>
	    <computeroutput>  0.00000 + 0.00000i  0.00000 + 0.00000i  2.10000 + 2.00000i</computeroutput>
	  </screen>

	  <para>Y para multiplicar vectores:</para>
	  <screen>
	    <prompt>octave:8> </prompt><userinput>v * w</userinput>
	    <computeroutput>ans = 1</computeroutput>
	    <prompt>octave:9> </prompt><userinput>w * v</userinput>
	    <computeroutput>ans =</computeroutput>
	    <computeroutput>   1   2   1</computeroutput>
	    <computeroutput>  -1  -2  -1</computeroutput>
	    <computeroutput>   2   4   2</computeroutput>
	    <prompt>octave:10> </prompt><userinput>v .* w'</userinput>
	    <computeroutput>ans =</computeroutput>
	    <computeroutput>  1 -2 2</computeroutput>
	  </screen>
	  <para>Los vectores v y w son vectores de 1x3 y 3x1 respectivamente, esto explica que en el
	  primer caso el resultado sea escalar y en el segundo una matriz 3x3. En el tercero se
	  multiplican las componentes una a una (operador <keysym>.*</keysym>), y para que esta
	  operación no de error es necesario que la dimensión de los dos operadores sea la misma. En
	  este caso se transpone <keysym>w</keysym> mediante el operador <keysym>'</keysym>
	  (apóstrofe): </para>
	  <screen>
	    <prompt>octave:11> </prompt><userinput>w'</userinput>
	    <computeroutput>ans =</computeroutput>
	    <computeroutput>   1 -1  2</computeroutput>
	  </screen>
	</example>

	<example>
	  <title>Solución de ecuaciones lineales</title>
	  <para>Para solver un conjunto de ecuaciones lineales del tipo <userinput>Ax=b</userinput>
	    disponemos del operador "división por la izquierda", <keysym>\</keysym>:</para>
	  <screen>
	    <prompt>octave:12> </prompt><userinput>A=[1 2 3; 3 1 2; 2 3 1];</userinput>
	    <prompt>octave:13> </prompt><userinput>A\w</userinput>
	    <computeroutput>ans =</computeroutput>
	    <computeroutput>  -0.55556</computeroutput>
	    <computeroutput>   1.11111</computeroutput>
	    <computeroutput>  -0.22222</computeroutput>
	  </screen>
	  <para>
	    <tip>
	      <para>Un <keysym>;</keysym> (punto y coma) al final de una orden hace que octave
	      después de ejecutar la orden suprima su respuesta y nos presente el siguiente prompt.</para>
	    </tip>
	  </para>
	</example>

	<example>
	  <title>Obteniendo ayuda</title>
	  <para>Para poder obtener información de Octave es necesario conocer el nombre de la orden
	  que se quiere usar. Este nombre no tiene por qué ser obvio. Un buen sitio para empezar es
	    simplemente teclear <keysym>help</keysym>. Esto nos mostrará todos los operadores,
	  palabras reservadas, funciones, variables predefinidas (built-in) y ficheros de
	  funciones. Si ya se conoce el nombre el comando, simplemente hay que pasarlo como
	  parámetro:</para>
	  <screen>
	    <prompt>octave:14> </prompt><userinput>help rand</userinput>
	    <computeroutput>zeros is a builtin function</computeroutput>
	    <computeroutput></computeroutput>
	    <computeroutput>zeros (N), zeros (N, M), zeros (X): create a matrix of all zeros</computeroutput>
	    <computeroutput></computeroutput>
	    <computeroutput>Additional help for builtin functions, operators, and variables</computeroutput>
	    <computeroutput>is available in the on-line version of the manual.  Use the command</computeroutput>
	    <computeroutput>`help -i &lt;topic&gt;' to search the manual index.</computeroutput>
	    <computeroutput></computeroutput>
	    <computeroutput>Help and information about Octave is also available on the WWW</computeroutput>
	    <computeroutput>at http://www.che.wisc.edu/octave/octave.html and via the</computeroutput>
	    <computeroutput>help-octave@bevo.che.wisc.edu mailing list.</computeroutput>
	  </screen>

	  <para>La tercera forma de obtener ayuda es por medio de <userinput>help -i concepto</userinput>,
	  donde <emphasis>concepto</emphasis> es la palabra clave que queremos buscar.
	    <caution>
	      <para>Para que este comando funcione es necesario tener instalada la utilidad externa
	      <keysym>info</keysym> (también software libre) y la documentación de octave en el
	      formato de esta herramienta.</para>
	    </caution>
	  </para>
	</example>
      </sect2>

      <sect2>
	<title>Comentarios en Octave</title>
	<para>Siempre es recomendable documentar el código, para hacerlo más inteligible a otras
	personas o al propio programador, por si en alguna ocasión tuviera que modificarlo. En
	Octave los comentarios empiezan con un signo <keysym>#</keysym> o <keysym>%</keysym>. Todo
	el texto que siga a continuación hasta fin de línea es considerado como un comentario y no
	es evaluado por Octave.</para>

	<screen>
	  <userinput>function y = determinante(X)</userinput>
	  <userinput>#</userinput>
	  <userinput># Uso: y = determinante(X)</userinput>
	  <userinput># </userinput>
	  <userinput># Esta función calcula el determinante de la matriz X</userinput>
	  <userinput># X debe ser una matriz cuadrada.</userinput>
	  <userinput>...</userinput>
	  <userinput>end</userinput>
	</screen>

	<para>En el ejemplo se muestra parte de la definición de una función. El comando de Octave
	  <userinput>help</userinput> es capaz de buscar el primer bloque de comentarios (aquel que
	  sucede justo después de la palabra clave <userinput>function</userinput>) e imprimirlo en
	  pantalla. Por ejemplo, después de definir la función anterior, cuando se teclee
	  <userinput>help determinante</userinput> se obtendrá el siguiente resultado:</para>

	<screen>
	  <userinput>function y = determinante(X)</userinput>
	  <userinput></userinput>
	  <userinput>Uso: y = determinante(X)</userinput>
	  <userinput></userinput>
	  <userinput>Esta función calcula el determinante de la matriz X</userinput>
	  <userinput>X debe ser una matriz cuadrada.</userinput>
	</screen>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title>Sintaxis de Octave</title>
    <para>Una de las características principales de Octave y que hacen de él una herramienta de
    fácil aprendizaje es la simplicidad e intuitividad de su lenguaje de programación. En los
    siguientes apartados se describen las reglas básicas para escribir órdenes y programas usando
    este lenguaje.</para>
    <sect1>
      <title>Tipos de datos</title>
      <para>Octave ofrece soporte para datos predefinidos, que incluyen escalares (reales y
      complejos), vectores, matrices, cadenas de caracteres y estructuras. También es posible la
      definición de nuevos datos por parte el usuario, programados en algún lenguaje que produzca
      código máquina (FORTRAN, C++, ...), aunque esta posibilidad aún no ha sido suficientemente
      documentada. Por este motivo en esta sección nos centraremos únicamente en los datos
      predefinidos (Built-in).</para>

      <sect2>
	<title>Objetos numéricos</title>
	<para>Los objetos numéricos predefinidos de octave son los escalares (reales y complejos), y
	las matrices (los vectores se consideran matrices especiales, en que una de sus dimensiones
	es 1). Todos los datos numéricos son almacenados como números de doble precisión, lo que
	significa que en sistemas que usan el formato en punto flotante de la IEEE se pueden
	representar números en el rango 2.2e-308 a 1.7e+308 y la precisión aproximada de
	2.2e-16.
	  <tip>
	    <para>Los valores exactos se encuentran en las variables <keysym>realmin</keysym>,
	    <keysym>realmax</keysym> y <keysym>eps</keysym>, respectivamente.</para>
	  </tip>
	</para>

	<sect3>
	  <title>Escalares</title>
	  <para>Los números escalares se pueden especificar en formato decimal, hexadecimal
	  (precedidos por el prefijo <keysym>0x</keysym>). Los números en formato hexadecimal sólo
	  pueden ser enteros. Los números decimales, además permiten usar notación científica,
	  pudiéndose utilizar los símbolos <keysym>e</keysym>, <keysym>E</keysym>,
	  <keysym>d</keysym> o <keysym>D</keysym> seguidos por un número <keysym>n</keysym> para
	  significar "multiplicado por 10 elevado a la potencia <keysym>n</keysym>. Algunos
	  ejemplos:</para>
	  <screen>
	    <userinput>105</userinput>
	    <userinput>1.05e2</userinput>
	    <userinput>1050E-1</userinput>
	    <userinput>0x69</userinput>
	  </screen>

	  <para>Todos ellos representan el número 105. Para representar el número complejo 10+11i:</para>
	  <screen>
	    <userinput>10 + 11i</userinput>
	    <userinput>1.0d1 + 0xBi </userinput>
	    <userinput>10 + 110D-1j</userinput>
	    <userinput>0xA + 0xbj</userinput>
	  </screen>
	  <para>Recordar que <keysym>i</keysym> y <keysym>j</keysym> y sus correspondientes
	  mayúsculas representan la unidad imaginaria, y que debe ser el último dígito de la
	  cantidad imaginaria y sin espacios con el resto del número. Tanto 100je-1, j100 o 100 j
	  son incorrectos.</para>
	</sect3>

	<sect3>
	  <title>Rangos numéricos</title>
	  <para>Un rango es una forma más cómoda de escribir un vector con elementos
	  equiespaciados. Un rango se define como una base o primer valor del rango, un valor opcional de
	  incremento entre elementos y un valor máximo que el rango no superará. Estos tres
	  elementos se separan por el símbolo <keysym>:</keysym> (dos puntos). El incremento puede
	  ser positivo o negativo, y en caso de omitirse se asumirá valor 1.</para>

	  <screen>
	    <prompt>octave> </prompt><userinput>1:10</userinput>
	    <computeroutput>ans = </computeroutput>
	    <computeroutput>   1   2   3   4   5   6   7   8   9  10</computeroutput>
	    <prompt>octave> </prompt><userinput>1:2:10</userinput>
	    <computeroutput>ans =</computeroutput>
	    <computeroutput>   1   3   5   7   9</computeroutput>
	  </screen>

	  <para>
	    <tip>
	      <para>El máximo del rango puede que no sea alcanzado en la expansión del rango. Si es
	      necesario que forme parte del conjunto de elementos y se conoce el número de elementos
	      que debe contener, se recomienda usar la función <keysym>linspace()</keysym> en su
	      lugar.</para>
	    </tip>
	  </para>
	</sect3>

	<sect3>
	  <title>Matrices</title>
	  <para>Es muy simple definir matrices en Octave. La definición se hace introduciendo los
	  elementos por filas, o bien concatenando otras matrices. Las dimensiones de la matriz son
	  determinadas automáticamente a partir de los datos. Se produce un error si alguna de las
	  filas o columnas de la matriz final tiene distinto número de elementos que el resto. Para
          separar filas podemos usar <keysym>;</keysym> (punto y coma) o presionar un retorno de
	  carro.</para>
	  <screen>
	    <prompt>octave> </prompt><userinput>a = [ 1 2; 3, 4 ]</userinput>
	    <computeroutput>a =</computeroutput>
	    <computeroutput>  1 2</computeroutput>
	    <computeroutput>  3 4</computeroutput>
	    <prompt>octave> </prompt><userinput>b = [ a a ]</userinput>
	    <computeroutput>b =</computeroutput>
	    <computeroutput>  1 2 1 2</computeroutput>
	    <computeroutput>  3 4 3 4</computeroutput>
	  </screen>

	  <para>Para recuperar un elemento de una matriz, simplemente tenemos que indicar el nombre
	  de la variable seguido por unos paréntesis, y dentro el índice de fila y el de columna
	  --en este orden-- del elemento que queramos recuperar.</para>

	  <screen>
	    <prompt>octave> </prompt><userinput>b(2,3)</userinput>
	    <computeroutput>ans = 3</computeroutput>
	  </screen>

	  <para> En el caso de un vector basta con indicar un sólo índice (el de la posición del
	  elemento), o se puede usar la notación de dos índices, pero en este caso si el vector es
	  un vector fila el primer índice valdrá uno y si es un vector columna será el segundo
	  índice el que valga uno.</para>

	  <para>Para recuperar varios elementos consecutivos de una misma fila de una
	  matriz (esto es un vector fila), usaremos un rango como segundo índice. Si en cambio
	  queremos  recuperar un vector columna, usaremos un rango como primer índice. Y si lo que
	  queremos es recuperar una submatriz usaremos rangos tanto para el primer como para el
	  segundo índice.</para>

	  <screen>
	    <prompt>octave> </prompt><userinput>b(1,2:3)</userinput>
	    <computeroutput>ans =</computeroutput>
	    <computeroutput>  2 1</computeroutput>
	    <prompt>octave> </prompt><userinput>b(1:2,3)</userinput>
	    <computeroutput>ans =</computeroutput>
	    <computeroutput>  1</computeroutput>
	    <computeroutput>  3</computeroutput>
	    <prompt>octave> </prompt><userinput>b(:,2:3)</userinput>
	    <computeroutput>ans =</computeroutput>
	    <computeroutput>  2 1</computeroutput>
	    <computeroutput>  3 4</computeroutput>
	  </screen>

	  <para>
	    <tip>
	      <para>Si se desean todos los elementos de una fila o de una columna, basta con indicar
		el rango sólo con los dos puntos: <userinput>b(1,:)</userinput> nos devolvería la
		primera fila de <userinput>b</userinput>.</para>
	    </tip>
	    <tip>
	      <para>Para más información, desde el prompt de Octave teclear <userinput>help -i
	      Matrices</userinput></para>
	    </tip>
	  </para>
	</sect3>

	<sect3>
	  <title>Cadenas de caracteres o strings</title>
	  <para>Las cadenas de caracteres o <keysym>strings</keysym>, como se les denomina en
	  Octave, son secuencias de caracteres encerrados entre comillas simples
	  (<keysym>'</keysym>) o dobles (<keysym>"</keysym>).
	    <tip>
	      <para>Como la comilla simple (<keysym>'</keysym>) es también el operador de
		transposición, se recomienda utilizar comillas dobles (<keysym>"</keysym>).</para>
	    </tip>
	  </para>

	  <para>Algunos caracteres no pueden ser incluidos de forma literal en un string, y es
	  necesario introducir secuencias de caracteres equivalentes (secuencias de escape). La
	  siguiente tabla muestra las secuencias de escape:</para>
	  <table>
	    <title>Secuencias de escape en strings</title>
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Secuencia</entry><entry>Descripción</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>\\</entry><entry>Contra-barra (backslash): <keysym>\</keysym>.</entry>
		</row>
		<row>
		  <entry>\"</entry><entry>Comillas dobles <keysym>"</keysym>. Sólo es necesario si
		  se utilizan las comillas dobles para limitar el string.</entry>
		</row>
		<row>
		  <entry>\'</entry><entry>Comillas simples <keysym>'</keysym>. Sólo es necesario si
		  se utilizan las comillas simples para limitar el string.</entry>
		</row>
		<row>
		  <entry>\a</entry><entry>Representa el carácter "alert" (normalmente suena el
		  pitido de terminal.</entry>
		</row>
		<row>
		  <entry>\b</entry><entry>Representa el carácter de borrado (backspace o
		  <keysym>control-h).</keysym></entry>
		</row>
		<row>
		  <entry>\f</entry><entry>Representa el carácter "formfeed" (nueva página).</entry>
		</row>
		<row>
		  <entry>\n</entry><entry>Representa el carácter "nueva línea".</entry>
		</row>
		<row>
		  <entry>\r</entry><entry>Representa el carácter "retorno de carro".</entry>
		</row>
		<row>
		  <entry>\t</entry><entry>Representa el carácter tabulador. Normalmente no es
		  necesario escaparlo, pero desde la línea de comandos de Octave el carácter
		  tabulador invoca la función de edición completar palabra.</entry>
		</row>
		<row>
		  <entry>\v</entry><entry>Representa un tabulador vertical.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>Las cadenas de caracteres pueden concatenarse utilizando la notación para definir
	  matrices. Por ejemplo:</para>
	  <screen>
	    <prompt>octave> </prompt><userinput>[ "Bien" , "venidos", " al ", "curso" ]</userinput>
	    <computeroutput>ans = Bienvenidos al curso</computeroutput>
	  </screen>

	  <para>
	    <tip>
	      <para>Para más información, desde el prompt de Octave teclear <userinput>help -i
	      strings</userinput></para>
	    </tip>
	  </para>
	</sect3>
      </sect2>

      <sect2>
	<title>Estructuras</title>
	<para>Octave posee soporte para organizar los datos en estructuras. La sintaxis es muy
	  similar a la del lenguaje <keysym>C</keysym>. Los datos de una estructura pueden ser de
	cualquier tipo. Por ejemplo:</para>

	<screen>
	  <prompt>octave> </prompt><userinput>x.numero = 1;</userinput>
	  <prompt>octave> </prompt><userinput>x.matriz = [1 2; 2 1];</userinput>
	  <prompt>octave> </prompt><userinput>x.cadena = "Hola";</userinput>
	  <prompt>octave> </prompt><userinput>x</userinput>
	  <computeroutput>x = </computeroutput>
	  <computeroutput>{</computeroutput>
	  <computeroutput>  cadena = hola</computeroutput>
	  <computeroutput>  numero = 1</computeroutput>
	  <computeroutput>  matriz =</computeroutput>
	  <computeroutput>    1 2</computeroutput>
	  <computeroutput>    2 1</computeroutput>
	  <computeroutput>}</computeroutput>
	</screen>

	<para>Las estructuras son ellas mismas objetos que pueden formar parte de otras
	estructuras. Las estructuras se pueden copiar (operador <keysym>=</keysym>) pero no tienen
	definida aritmética ni pueden ser elementos de una matriz. En casos en que hay anidamiento
	de estructuras, al mostrar el valor de un objeto de tipo estructura, octave puede elegir
	truncar la representación de algunos miembros para evitar confusión. Por ejemplo:</para>
	<screen>
	  <prompt>octave> </prompt><userinput>a.b.c.d=1;</userinput>
	  <prompt>octave> </prompt><userinput>a</userinput>
	  <computeroutput>a =</computeroutput>
	  <computeroutput>{</computeroutput>
	  <computeroutput>  b =</computeroutput>
	  <computeroutput>  {</computeroutput>
	  <computeroutput>    c = &lt;structure&gt;</computeroutput>
	  <computeroutput>  }</computeroutput>
	  <computeroutput>}</computeroutput>
	</screen>

	<para>
	  <tip>
	    <para>El número de niveles de anidamiento de estructuras que se muestra se puede cambiar
	    con la variable predefinida <keysym>struct_levels_to_print</keysym>. Su valor por
	    omisión es de 2.</para>
	  </tip>
	  <tip>
	    <para>Para más información, desde el prompt de Octave teclear <userinput>help -i
	    struct</userinput></para>
	  </tip>
	</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Variables</title>
      <para>Las variables nos permiten dar nombre a los valores que nos interesa guardar y poder
      referirnos a ellos más tarde. Ya se han visto muchos ejemplos de variables en los ejemplos
      anteriores. El nombre de una variable debe ser una secuencia de letras, dígitos, y subrayados
      (guión bajo), pero no puede empezar por dígito. Octave no impone ninguna restricción a la
      longitud de los nombres de variables. </para>

      <para>Sin embargo nombres que empiecen por dos subrayados se reservan para el uso interno de
      Octave y sólo se deberán en el bodigo para acceder a las variables predefinidas (y
      documentadas) de Octave.</para>

      <para>El nombre de una variable es una expresión válida. Representa el valor almacenado en la
      variable. Una variable se define cuando se le asigna valor por primera vez, y no hay ningún
      problema en asignarle posteriormente distintos valores, aunque sean de otros tipos (por
      ejemplo entero y string). Se da valor a una variable utilizando el operador igual
      (<keysym>=</keysym>) y si se trata de variables numéricas, con los operadores de
      incremento.
	<tip>
	  <para>Este tema se tratará con más profundidad en la sección <xref linkend="operadores">.</para>
	</tip>
      </para>

      <para>Existen algunas variables predefinidas que tienen un significado especial, por ejemplo
      algunas permiten configurar la forma en que se comporta Octave, y otras almacenan constantes
      matemáticas útiles. Algunas de ellas son constantes y no pueden cambiarse, otras son pueden
      ser modificadas exactamente igual que una variable normal.</para>

      <para>Las variables en Octave no tienen tipo fijo, así que es posible almacenar distintos
      tipos de dato en la misma variable. Únicamente hemos de ser cuidadosos para no utilizar una
      variable antes de haberla definido.</para>

      <para>Un tipo especial de variable son las variables globales. Una variable global es aquella
      que se declara utilizando la palabra reservada <keysym>global</keysym>. Una variable declarada
      de esta manera puede ser accedida desde cualquier ámbito, independientemente de dónde se haya
      definido.</para>
      <para>
	<tip>
	  <para>Para más información, consultar <userinput>help -i Variables</userinput></para>
	</tip>
      </para>
    </sect1>

    <sect1 id="operadores">
      <title>Operadores</title>

      <para>Los operadores permiten construir sentencias más complejas. Es posible concatenar
	operaciones. Su precedencia es semejante a la de otros lenguajes, pero es posible
	modificarla agrupando las expresiones entre paréntesis.
	<tip>
	  <para>Para obtener la lista completa de la precedencia de los operadores teclear
	  <userinput>help -i precedence</userinput></para>
	</tip>
      </para>

      <sect2>
	<title>Operadores aritméticos</title>
	<para>Operan sobre escalares y matrices.</para>
	<table>
	  <title>Operadores aritméticos</title>
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Operador</entry>
		<entry>Descripción</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><userinput>x + y</userinput></entry>
		<entry>Suma. Si los dos operadores son matrices las dimensiones deben coincidir. Si
		no el escalar se suma a cada elemento de la matriz.</entry>
	      </row>
	      <row>
		<entry><userinput>x .+ y</userinput></entry>
		<entry>Suma elemento a elemento. Esta operación es equivalente a
		<userinput>+.</userinput></entry>
	      </row>
	      <row>
		<entry><userinput>x - y</userinput></entry>
		<entry>Resta. El resultado es equivalente a <userinput>x + (-y)</userinput>, donde
		  <userinput>-y</userinput> representa el opuesto de <userinput>y</userinput>.</entry>
	      </row>
	      <row>
		<entry><userinput>x .- y</userinput></entry>
		<entry>Resta elemento a elemento. Esta operación equivale a <userinput>-.</userinput></entry>
	      </row>
	      <row>
		<entry><userinput>x * y</userinput></entry>
		<entry>Multiplicación de matrices. El número de columnas de <userinput>x</userinput>
		  debe coincidir con el número de filas de <userinput>y</userinput>.</entry>
	      </row>
	      <row>
		<entry><userinput>x .* y</userinput></entry>
		<entry>Multiplicación de matrices elemento a elemento.</entry>
	      </row>
	      <row>
		<entry><userinput>x / y</userinput></entry>
		<entry>División a derechas. Conceptualmente es equivalente a <userinput>(inverso
		    (y') * x')'</userinput>, pero sin necesidad de calcular la inversa de
		<userinput>y</userinput> ni calcular las transpuestas de las matrices.</entry>
	      </row>
	      <row>
		<entry><userinput>x ./ y</userinput></entry>
		<entry>División elemento a elemento, de los elementos de <userinput>x</userinput>
		  divididos por los elementos de <userinput>y</userinput>.</entry>
	      </row>
	      <row>
		<entry><userinput>x \ y</userinput></entry>
		<entry>División por la izquierda. Conceptualmente es equivalente a
		<userinput>inverso (x) * y</userinput>.</entry>
	      </row>
	      <row>
		<entry><userinput>x .\ y</userinput></entry>
		<entry>División elemento a elemento, de los elementos de <userinput>y</userinput>
		entre los elementos de <userinput>x</userinput></entry>
	      </row>
	      <row>
		<entry><userinput>x ^ y</userinput> o <userinput>x ** y</userinput></entry>
		<entry>Operación de exponenciación. Ambos operadores no pueden ser matrices, y si
		alguno es matriz, deberá ser cuadrada.</entry>
	      </row>
	      <row>
		<entry><userinput>x .^ y</userinput> o <userinput>x .** y</userinput></entry>
		<entry>Exponenciación, elemento a elemento. Si ambos operadores son matrices,
		deberán tener igual dimensión.</entry>
	      </row>
	      <row>
		<entry><userinput>-x</userinput></entry>
		<entry>Negación. Se obtiene el escalar opuesto o la matriz de igual dimensión y
		cuyos elementos son los opuestos de la matriz original.</entry>
	      </row>
	      <row>
		<entry><userinput>+x</userinput></entry>
		<entry>Operador suma unitario. No tiene ninguna consecuencia sobre el operando.</entry>
	      </row>
	      <row>
		<entry><userinput>x'</userinput></entry>
		<entry>Conjugado complejo y transpuesta. Para números reales es equivalente a la
		transposición.</entry>
	      </row>
	      <row>
		<entry><userinput>x.'</userinput></entry>
		<entry>Transposición de los elementos de <userinput>x</userinput>. No se conjugan
		los elementos.</entry>
	      </row>
	      <row>
		<entry><userinput>++x</userinput></entry>
		<entry>Operador de preincremento. Equivalente a ejecutar la expresión
		<userinput>x=x+1</userinput> antes de acceder al valor de <userinput>x</userinput></entry>
	      </row>
	      <row>
		<entry><userinput>--x</userinput></entry>
		<entry>Operador de predecremento. Equivalente a ejecutar la expresión
		<userinput>x=x-1</userinput> antes de acceder al valor de <userinput>x</userinput></entry>
	      </row>
	      <row>
		<entry><userinput>x++</userinput></entry>
		<entry>Operador de postincremento. Equivalente a ejecutar la expresión
		<userinput>x=x+1</userinput> después de acceder al valor de <userinput>x</userinput></entry>
	      </row>
	      <row>
		<entry><userinput>x--</userinput></entry>
		<entry>Operador de postdecremento. Equivalente a ejecutar la expresión
		<userinput>x=x-1</userinput> después de acceder al valor de <userinput>x</userinput></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	<para>
	  <tip>
	    <para>Si el valor de la variable predefinida <keysym>warm_divide_by_zero</keysym> es
	    distinto de cero, y en algún caso se produce una división por cero, Octave imprime un
	    aviso y continúa con las operaciones.</para>
	  </tip>
	</para>
      </sect2>

      <sect2>
	<title>Operadores de comparación.</title>
	<para>Todos los operadores de comparación devuelven un valor 1 si la comparación es cierta,
	y 0 si es falsa. Para matrices las operaciones se realizan operando a operando. Por
	ejemplo:</para>

	<screen>
	  <prompt>octave> </prompt><userinput>[1 2; 3 4] == [1 3; 2 4]</userinput>
	  <computeroutput>ans =</computeroutput>
	  <computeroutput>  1 0</computeroutput>
	  <computeroutput>  0 1</computeroutput>
	</screen>

	<para>Si un operador es escalar y el otro una matriz, el escalar se compara con cada
	elemento de la matriz y el resultado tiene las mismas dimensiones que la matriz.</para>

	<table>
	  <title>Operadores de comparación</title>
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Operador</entry>
		<entry>Descripción</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><userinput>x &lt y</userinput></entry>
		<entry>Cierto si <userinput>x</userinput> es menor que <userinput>y</userinput>.</entry>
	      </row>
	      <row>
		<entry><userinput>x &lt;= y</userinput></entry>
		<entry>Cierto si <userinput>x</userinput> es menor o igual que <userinput>y</userinput>.</entry>
	      </row>
	      <row>
		<entry><userinput>x == y</userinput></entry>
		<entry>Cierto si <userinput>x</userinput> es igual que <userinput>y</userinput>.</entry>
	      </row>
	      <row>
		<entry><userinput>x > y</userinput></entry>
		<entry>Cierto si <userinput>x</userinput> es mayor que <userinput>y</userinput>.</entry>
	      </row>
	      <row>
		<entry><userinput>x >= y</userinput></entry>
		<entry>Cierto si <userinput>x</userinput> es mayor o igual que <userinput>y</userinput>.</entry>
	      </row>
	      <row>
		<entry><userinput>x != y</userinput> o <userinput>x ~= y</userinput> o <userinput>x
		&lt;&gt y</userinput></entry>
		<entry>Cierto si <userinput>x</userinput> no es igual a <userinput>y</userinput>.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>
	  <tip>
	    <para>Las comparaciones con cadenas de caracteres pueden hacerse con la función
	      <userinput>strcmp</userinput>.</para>
	  </tip>
	</para>
      </sect2>

      <sect2>
	<title>Operadores booleanos</title>
	<para>El resultado de un operador booleano es una matriz de dimensión equivalente a los operandos,
	donde cada elemento es el resultado de aplicar el operador booleano a los elementos
	correspondientes. Se considera como cierto un valor distinto de cero, y falso un valor igual
	a cero.Los operadores booleanos se pueden emplear en las mismas situaciones que
	los operadores de comparación. Si además se utilizan en estructuras de control de flujo
	(<keysym>if</keysym> o <keysym>while</keysym>) sólo serán cierto si todos los elementos
	son distintos de cero.</para>
	<screen>
	  <prompt>octave> </prompt><userinput>[1 0] & [1 1]</userinput>
	  <computeroutput>ans = 1 0</computeroutput>
	</screen>

	<para>Únicamente hay tres operadores booleanos:</para>
	  <table>
	    <title>Operadores booleanos</title>
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Operador</entry>
		<entry>Descripción</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><userinput>boolean1 & boolean2</userinput></entry>
		<entry>Operador 'and' lógico. Cada elementos del resultado es cierto si los elementos
		correspondientes de los operandos lo son.</entry>
	      </row>
	      <row>
		<entry><userinput>boolean1 | boolean2</userinput></entry>
		<entry>Operador 'or' lógico. Cada elementos del resultado es cierto si alguno de los
		elementos correspondientes de los operandos lo es.</entry>
	      </row>
	      <row>
		<entry><userinput>! boolean</userinput> o <userinput>~ boolean</userinput></entry>
		<entry>Operador 'not' lógico. Cada elemento del resultado toma el valor booleano
		opuesto al del operando.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	  </table>
      </sect2>

      <sect2>
	<title>Operadores booleanos "short-circuit"</title>
	<para>Los operadores booleanos de "corto circuito" son semejantes a los operadores
	booleanos, con la diferencia de que si después de evaluar el primer operando, ya es
	suficiente para obtener el resultado, no se comprueba el segundo operando.</para>

	<table>
	  <title>Operadores binarios de corto circuito</title>
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Operador</entry>
		<entry>Descripción</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><userinput>boolean1 && boolean2</userinput></entry>
		<entry>El operando <userinput>boolean1</userinput> es evaluado y convertido a un
		  escalar (el resultado es análogo a <userinput>all(boolean1)</userinput>). Si el
		resultado es falso, la operación termina con resultado falso. Si es cierto se
		realiza la misma operación con el segundo operando y este será el resultado de la
		operación.</entry>
	      </row>
	      <row>
		<entry><userinput>boolean1 || boolean2</userinput></entry>
		<entry>El operando <userinput>boolean1</userinput> es evaluado y convertido a un
		  escalar (el resultado es análogo a <userinput>any(boolean1)</userinput>. Si el
		resultado es verdadero, la operación termina con resultado verdadero. En cambio si
		fue falso se evalúa de la misma manera el segundo operando el resultado obtenido
		será el resultado de la operación.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>La diferencia entre los operadores binarios normales y los de cortocircuito se verá
	mejor con un ejemplo:</para>

	<screen>
	  <prompt>octave> </prompt><userinput>a=0; b=0; a & b++, b</userinput>
	  <computeroutput>ans = 0</computeroutput>
	  <computeroutput>b = 1</computeroutput>
	  <prompt>octave> </prompt><userinput>a=0; b=0; a && b++, b</userinput>
	  <computeroutput>ans = 0</computeroutput>
	  <computeroutput>b = 0</computeroutput>
	</screen>
	<para>En el segundo caso, <userinput>b</userinput> será incrementado sólo si
	  <userinput>a</userinput> es verdadero. En el primer caso <userinput>b</userinput> siempre
	  será incrementado.</para>
      </sect2>

      <sect2>
	<title>Operador de asignación</title>
	<para>El signo <keysym>=</keysym> es el operador de asignación. Después de una asignación
	una variable cambia de valor y de tipo para acomodarse al del nuevo valor. El operador
	asignación es la única manera de poder almacenar valores. En el lado derecho puede aparecer
	cualquier expresión de las descritas anteriormente en este capítulo, o funciones que
	devuelvan un valor. En el lado izquierdo podemos tener variables, elementos de una matriz o
	vector, o listas de valores de retorno (este concepto se aclarará en el apartado dedicado a
	funciones). Ejemplos:</para>
	<screen>
	  <prompt>octave> </prompt><userinput>a=1;</userinput>
	  <prompt>octave> </prompt><userinput>b=ones(2,3);</userinput>
	  <prompt>octave> </prompt><userinput>b(:,1)= 2</userinput>
	  <computeroutput>b =</computeroutput>
	  <computeroutput>  2 1 1</computeroutput>
	  <computeroutput>  2 1 1</computeroutput>
	  <prompt>octave> </prompt><userinput>[d c]= size(b);</userinput>
	  <prompt>octave> </prompt><userinput>e=["esta " "es " "una " "cadena"];</userinput>
	</screen>

      </sect2>

    </sect1>
    <sect1>
      <title>Expresiones de control de flujo</title>
      <para>Las expresiones de control de flujo influyen en la forma en que el código es ejecutado,
	y dividen el código en bloques. Los bloques empiezan con una palabra reservada, por ejemplo
	<userinput>while</userinput> y terminan con la palabra reservada
      <userinput>endwhile</userinput>, formada por el prefijo end y la misma palabra que empezó el
	bucle. También es posible acabar un bloque con la palabra <userinput>end</userinput>. El
      código que se entre dichas palabras se denomina el cuerpo de la expresión de control.</para>

      <para>Las siguientes construcciones son posibles</para>

      <sect2>
	<title>Sentencia <userinput>if</userinput></title>

	<screen>
	  <userinput>if (condicion)</userinput>
	  <userinput>   cuerpo-entonces</userinput>
	  <userinput>end</userinput>
	</screen>

	<screen>
	  <userinput>if (condicion)</userinput>
	  <userinput>   cuerpo-entonces</userinput>
	  <userinput>else</userinput>
	  <userinput>   cuerpo-alternativa</userinput>
	  <userinput>end</userinput>
	</screen>

	<screen>
	  <userinput>if (condicion)</userinput>
	  <userinput>   cuerpo-entonces</userinput>
	  <userinput>elseif (condicion)</userinput>
	  <userinput>   cuerpo-entonces</userinput>
	  <userinput>else</userinput>
	  <userinput>   cuerpo-alternativa</userinput>
	  <userinput>end</userinput>
	</screen>

	<para>Si la condición del <userinput>if</userinput> es cierta, entonces se ejecuta el
	  cuerpo-entonces que está a continuación. Si es falso se pasa a evaluar la condición del
	  siguiente <userinput>elseif</userinput>, ejecutando se el código correspondiente
	  si su condición es cierta, o pasando al siguiente en caso contrario. Finalmente, si ninguna
	  condición evaluó cierta se ejecuta el cuerpo-alternativa.</para>

	<para>Tanto los <userinput>elseif</userinput>, como el <userinput>else</userinput> son
	  opcionales, sin embargo puede haber tantos <userinput>elseif</userinput> como sean necesarios.</para>
      </sect2>

      <sect2>
	<title>Sentencia <userinput>while</userinput></title>
	<para>La sintaxis es la siguiente</para>
	<screen>
	  <userinput>while (condicion)</userinput>
	  <userinput>   cuerpo</userinput>
	  <userinput>endwhile</userinput>
	</screen>

	<para>Las sentencias del cuerpo se ejecutaran mientras condición se siga evaluando a
	cierto. Si en el cuerpo no se modifica alguna de las variables que se evalúan en la
	condición entraremos en un bucle infinito.</para>
      </sect2>

      <sect2>
	<title>Sentencia <userinput>for</userinput></title>
	<para>La sintaxis de la sentencia <userinput>for</userinput> es muy semejante a la del
	  <userinput>while</userinput>.</para>

	<screen>
	  <userinput>for var = expresion</userinput>
	  <userinput>   body</userinput>
	  <userinput>endfor</userinput>
	</screen>

	<para>En el bucle for se evalúa la expresión una vez al principio y se asigna a la variable
	<userinput>var</userinput>. Sin embargo la expresión de asignación del
	<userinput>for</userinput> funciona un poco distinto que en el resto de los casos. En lugar
	de asignar la expresión completa, se asigna sólo una columna y el bucle va iterando en todas
	las columnas. Por ejemplo</para>

	<screen>
	  <prompt>octave> </prompt><userinput>for a=ones(2,1)*[1:3]</userinput>
	  <prompt>> </prompt><userinput>    a</userinput>
	  <prompt>> </prompt><userinput>endfor</userinput>
	  <computeroutput>a =</computeroutput>
	  <computeroutput>  1</computeroutput>
	  <computeroutput>  1</computeroutput>
	  <computeroutput>a =</computeroutput>
	  <computeroutput>  2</computeroutput>
	  <computeroutput>  2</computeroutput>
	  <computeroutput>a =</computeroutput>
	  <computeroutput>  3</computeroutput>
	  <computeroutput>  3</computeroutput>
	</screen>

	<para>Normalmente el bucle <userinput>for</userinput> se usa cuando se quieren hacer las
	cosas cierto número de veces (tantas como columnas tenga el resultado de evaluar la expresión).</para>
      </sect2>

      <sect2>
	<title>Sentencias <userinput>break</userinput> y <userinput>continue</userinput></title>
	<para>Estas sentencias sólo pueden usarse dentro de bucles <userinput>for</userinput> y
	  <userinput>while</userinput>.</para>

	<para><userinput>break</userinput> salta fuera del bucle más interno que lo encierra. En el
	  siguiente ejemplo, el bucle terminará cuando la variable <userinput>var</userinput> valga
	  3:</para>

	<screen>
	  <userinput>for var=1:10</userinput>
	  <userinput>   a</userinput>
	  <userinput>   if(a==3)</userinput>
	  <userinput>       break</userinput>
	  <userinput>   endif</userinput>
	  <userinput>endfor</userinput>
	</screen>

	<para>La sentencia <userinput>continue</userinput> es semejante, pero en lugar de terminar
	el bucle termina sólo la iteración actual. Ejemplo:</para>

	<screen>
	  <userinput>for var=1:10</userinput>
	  <userinput>   if(a==3)</userinput>
	  <userinput>       continue</userinput>
	  <userinput>   endif</userinput>
	  <userinput>   a</userinput>
	  <userinput>endfor</userinput>
	</screen>

	<para>En este caso el bucle llegará hasta el final (<userinput>a=10</userinput>), pero no se
	  imprimirá el valor de <userinput>a</userinput> cuando esta valga 3.</para>

	<para>Normalmente estas dos sentencias se usan desde dentro de condiciones
	<userinput>if</userinput>.</para>
      </sect2>

      <sect2>
	<title>Manejo de excepciones</title>
	<para>Octave soporta un manejo limitado de excepciones con la sentencia
	<userinput>try</userinput>. La sintaxis es la siguiente:</para>

	<screen>
	  <userinput>try</userinput>
	  <userinput>   cuerpo</userinput>
	  <userinput>catch</userinput>
	  <userinput>   código_de_recuperacion</userinput>
	  <userinput>end_try_catch</userinput>
	</screen>

	<para>El código_de_recuperación únicamente es ejecutado si sucede algún error en el
	cuerpo. Durante la ejecución del cuerpo no se imprime ningún mensaje de error. Si alguno
	  ocurre se almacenan en la variable <userinput>__error_text__</userinput>, accesible desde
	el código_de_recuperación.</para>
      </sect2>

    </sect1>
    <sect1>
      <title>Funciones y scripts de usuario</title>
      <para>Las funciones y scripts son el mecanismo que ofrece Octave para simplificar la escritura
      de programas o la carga de datos iniciales. Se pueden escribir directamente en la línea de
      comandos de Octave, o en ficheros externos. En ese caso los scripts y las funciones se invocan
      exactamente igual que cualquier otra función predefinida de Octave. La única condición es que
      esos ficheros se encuentren en un directorio dentro del path de Octave
	<tip>
	  <para>Para más información sobre el path de búsqueda de ficheros de Octave consultar
	  <userinput>help -i LOADPATH</userinput>.</para>
	</tip>
	<tip>
	  <para>Los ficheros de scripts y funciones de Octave tienen extensión ".m" por
	  compatibilidad con Matlab.</para>
	</tip>
      </para>

      <para>Las funciones tienen el siguiente formato:</para>

      <screen>
	<userinput><keysym>function</keysym> variable_retornada <keysym>=</keysym> nombre_funcion <keysym>(</keysym>lista_argumentos<keysym>)</keysym></userinput>
	<userinput>   cuerpo_de_función</userinput>
	<userinput><keysym>endfunction</keysym></userinput>
      </screen>

      <para>El formato tiene los siguientes campos:</para>
      <itemizedlist>
	<listitem>
	  <para>Empiezan con la palabra clave <keysym>function</keysym> que indica el inicio de la
	  declaración de una función de octave.</para>
	</listitem>
	<listitem>
	  <para>Opcionalmente sigue la declaración de las variables retornadas. Puede ser una única
	    variable (de cualquier tipo permitida en octave) o una lista de variables entre
	    corchetes (<keysym>[]</keysym>). Las variables pueden ser de distintos tipos.</para>

	  <para>Si no existe la lista de variables, tampoco deberá aparecer el signo igual y la
	  función no devolverá ningún valor.</para>
	</listitem>
	<listitem>
	  <para>El nombre de la función</para>
	</listitem>
	<listitem>
	  <para>Opcionalmente sigue la lista de argumentos entre paren tesis <keysym>()</keysym> y
	  separados por comas. Si no aparece la lista de argumentos la función no tendrá parámetros
	  de entrada.</para>
	</listitem>
	<listitem>
	  <para>A continuación sigue el código o cuerpo de la función.</para>
	</listitem>
	<listitem>
	  <para>La función termina con la palabra <keysym>end</keysym> o <keysym>endfunction</keysym>.</para>
	</listitem>
      </itemizedlist>

      <screen>
	<userinput>function [x y] = polar2cartesiano(radio, angulo)</userinput>
	<userinput>  x= radio*cos(angulo);</userinput>
	<userinput>  y= radio*sin(angulo);</userinput>
	<userinput>endfuncion</userinput>
      </screen>

      <para>Para que sea posible la devolución de algún valor, dentro del cuerpo de la función deben
      existir variables de igual nombre que las que aparecen en el campo variable_retornada. No es
      necesario devolver ningún valor explícitamente.</para>

      <para>Dentro del cuerpo de la función son accesibles las variables declaradas en la lista de
      argumentos, que tendrán el valor que se les asignó al hacer la llamada (la forma de asignar
      los valores a las variables es por la posición, es decir, el primer valor será asignado a la
      primera variable de la lista de argumentos). Si el último de los argumentos de la función es
      el símbolo <keysym>...</keysym>, significa que la función admite un número indeterminado de
      parámetros. Es responsabilidad del programador afrontar el tratamiento de los parámetros no
      declarados explícitamente.</para>

      <para>Se puede terminar en cualquier momento la ejecución de la función usando la palabra
	<keysym>return</keysym>.</para>

      <para>Además de lo anterior, dentro del cuerpo de la función está disponible la variable
	<keysym>nargin</keysym>. Su valor es asignado automáticamente al número de parámetros que se
	han pasado en la llamada. Esto puede permitirnos hacer un pequeño chequeo antes de continuar
	con la ejecución del resto del código y evitar fallos por falta de parámetros. Por ejemplo:</para>

      <screen>
	<userinput>function [x y] = polar2cartesiano(radio, angulo)</userinput>
	<userinput>  if(nargin!=2)</userinput>
	<userinput>    fprintf(2,"Error, el número de parámetros debe ser 2\n");</userinput>
	<userinput>    return</userinput>
	<userinput>  endif</userinput>
	<userinput>  x= radio*cos(angulo);</userinput>
	<userinput>  y= radio*sin(angulo);</userinput>
	<userinput>endfuncion</userinput>
      </screen>

      <para>Excepto para pequeños "programillas de juguete", no es práctico tener que definir todas
      las funciones cada vez. En lugar de ello es posible guardarlos en ficheros de texto y así
      conservarlos para futuros usos.</para>

      <para>Octave no requiere que se carguen las funciones antes de usarlas. Simplemente es necesario
      que se guarden en un fichero con extensión ".m", en un directorio de los indicados en la
      variable <keysym>LOADPATH</keysym>, y que el nombre del fichero coincida con el de la función.</para>

      <para>Los scritps son simples ficheros de texto en el que se introducen las sentencias de la
      misma manera que se introducen en la línea de comandos. Su principal utilidad es definir un
      entorno de trabajo en cualquier momento, definiendo una serie de variables y/o funciones. Cada
      vez que queramos recuperar ese estado deberemos volver a invocar el script por su nombre (in
      la extensión). La única restricción es que la primera sentencia no debe ser la definición de
      una función. En caso contrario Octave pensará que se trata de un fichero de función y los
      resultados no serán los esperados.</para>

    </sect1>
  </chapter>

  <chapter>
    <title>Funciones de entrada/salida</title>
    <sect1>
      <title>Funciones básicas de escritura en disco.</title>
      <para>Estas funciones son <keysym>save</keysym> y <keysym>load</keysym>. La primera guarda
      variables a un fichero, la segunda carga variables de un fichero al espacio de trabajo.</para>

      <para><userinput>help load</userinput></para>
      <para><userinput>help save</userinput></para>
    </sect1>
<!--    <sect1>
      <title>Entrada y salida con formato.</title>
      <para></para>
    </sect1>  -->
    <sect1>
      <title>Gráficas</title>
      <para>Octave normalmente está configurado para usar <application>gnuplot</application> para
	representar sus gráficos. El programa externo elegido puede configurarse con la variable
	<keysym>gnuplot_binary</keysym>.</para>

      <para>Existen cuatro funciones para representar gráficas en Octave: <keysym>plot()</keysym> y
	<keysym>mesh()</keysym> para representaciones en 2 y 3 dimensiones respectivamente. Admiten
      como parámetros vectores y matrices para representar (cuidado con las dimensiones).</para>

      <para>Las otras dos funciones son <keysym>gplot</keysym> y <keysym>gsplot</keysym>. Son
	simples interfaces para las funciones <keysym>plot</keysym> y <keysym>splot</keysym> del
	programa <application>gnuplot</application>, y por lo tanto admiten la misma
	sintaxis.</para>

      <para>Para obtener más información <userinput>help nombre_funcion</userinput></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Problemas de álgebra lineal</title>
    <para>En esta sección se nombrarán algunas de las utilidades que posee Octave para resolver
    problemas de álgebra lineal y se plantearán algunos ejemplos.</para>
  </chapter>

  <chapter>
    <title>Estadística</title>
    <para>En esta sección se nombrarán algunas de las utilidades de Octave para realizar cálculos y
    representaciones estadísticas. Se plantearán algunos ejemplos.</para>
  </chapter>
  <chapter>
    <title>Procesado de señal</title>
    <para>Aquí se describen las capacidades de Octave para realizar procesado digital de la
      señal. Se describirán algunas de las funciones fundamentales, tales como
    <keysym>fft()</keysym> o transformada rápida de Fourier. Se resolverán algunos problemas típicos.</para>
    <sect1>
      <title>Procesado de audio</title>
      <para>Se mostrará algunas de las facilidades que ofrece Octave para el procesado de audio:
      grabación, reproducción, codificación. </para>
    </sect1>
    <sect1>
      <title>Procesado de imagen</title>
      <para>Se describen algunas de las funciones de procesado de imagen y se muestra algún ejemplo
      de procesado.</para>
      <para>Octave utiliza los programas <application>xv</application> o
      <application>xloadimiage</application> para mostrar las imágenes.</para>
    </sect1>
  </chapter>

<!--  <chapter>
    <title>Código compilado en lugar de interpretado</title>
    <para></para>
  </chapter>  -->

  <chapter>
    <title>Referencias</title>
     <para>Octave es un programa muy extenso (y fácilmente extensible), de gran utilidad en el mundo
     de la ingeniería, las ciencias, la informática y muchos otros campos de la ciencia en que se
     necesite una herramienta suficientemente potente para realizar todo tipo de cálculo numérico, y
     a la vez sencilla que permita un fácil aprendizaje</para>
     
    <para>Este documento ha tratado de ser una introducción a Octave, centrándose principalmente en
    las particularidades del lenguaje. Si se desea profundizar más en el aprendizaje de Octave, se
    recomiendan las siguientes referencias.</para>

    <itemizedlist>
      <listitem>
	<para>La ayuda en línea: desde el prompt de Octave tecleando "help".</para>
      </listitem>
      <listitem>
	<para>La página oficial de Octave:
	  <ulink url="http://www.octave.org">http://www.octave.org</ulink></para>
	<para>Esta página centraliza toda la información de octave. Es el principal punto de
	  referencia.</para>
      </listitem>
      <listitem>
	<para>MatLinks/Chorus <ulink
	url="http://sourceforge.net/projects/matlinks/">http://sourceforge.net/projects/matlinks/</ulink>.
	Proyecto Open Source que pretende desarrollar, coordinar y organizar funciones y código de
	cálculo matemático. El objetivo final es desarrollar "ToolBoxes" similares a las de Matlab.</para>
      </listitem>
    </itemizedlist>

    <para>Octave forma parte de prácticamente todas las distribuciones de Linux, por lo que obtener
    el programa y la documentación es tan simple como instalar los paquetes correspondientes.</para>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-default-dtd-file:"~/.emacs.d/docbook.ced"
End:
-->
